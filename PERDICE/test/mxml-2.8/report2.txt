
mxml-file.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <mxml_string_putc>:
  char	**pp;				/* Pointer to string pointers */


  pp = (char **)p;

  if (pp[0] < pp[1])
       0:	48 8b 06             	mov    (%rsi),%rax
       3:	48 3b 46 08          	cmp    0x8(%rsi),%rax
       7:	73 03                	jae    c <mxml_string_putc+0xc>
    pp[0][0] = ch;
       9:	40 88 38             	mov    %dil,(%rax)

  pp[0] ++;
       c:	48 ff 06             	incq   (%rsi)

  return (0);
}
       f:	31 c0                	xor    %eax,%eax
      11:	c3                   	retq   

0000000000000012 <mxml_write_ws>:
              void            *p,	/* I - Write pointer */
              mxml_save_cb_t  cb,	/* I - Callback function */
	      int             ws,	/* I - Where value */
	      int             col,	/* I - Current column */
              _mxml_putc_cb_t putc_cb)	/* I - Write callback */
{
      12:	41 56                	push   %r14
      14:	49 89 f6             	mov    %rsi,%r14
      17:	89 ce                	mov    %ecx,%esi
      19:	41 55                	push   %r13
      1b:	41 54                	push   %r12
      1d:	4d 89 cc             	mov    %r9,%r12
      20:	55                   	push   %rbp
      21:	53                   	push   %rbx
      22:	44 89 c3             	mov    %r8d,%ebx
      25:	48 83 ec 10          	sub    $0x10,%rsp
  const char	*s;			/* Whitespace string */


  if (cb && (s = (*cb)(node, ws)) != NULL)
      29:	48 85 d2             	test   %rdx,%rdx
      2c:	74 4e                	je     7c <mxml_write_ws+0x6a>
      2e:	ff d2                	callq  *%rdx
      30:	48 85 c0             	test   %rax,%rax
      33:	48 89 c5             	mov    %rax,%rbp
      else if (*s == '\n')
	col = 0;
      else if (*s == '\t')
      {
	col += MXML_TAB;
	col = col - (col % MXML_TAB);
      36:	41 bd 08 00 00 00    	mov    $0x8,%r13d
              _mxml_putc_cb_t putc_cb)	/* I - Write callback */
{
  const char	*s;			/* Whitespace string */


  if (cb && (s = (*cb)(node, ws)) != NULL)
      3c:	75 37                	jne    75 <mxml_write_ws+0x63>
      3e:	eb 3c                	jmp    7c <mxml_write_ws+0x6a>
  {
    while (*s)
    {
      if ((*putc_cb)(*s, p) < 0)
      40:	0f be f8             	movsbl %al,%edi
      43:	4c 89 f6             	mov    %r14,%rsi
      46:	41 ff d4             	callq  *%r12
      49:	85 c0                	test   %eax,%eax
      4b:	79 05                	jns    52 <mxml_write_ws+0x40>
      4d:	83 cb ff             	or     $0xffffffffffffffff,%ebx
      50:	eb 2a                	jmp    7c <mxml_write_ws+0x6a>
	return (-1);
      else if (*s == '\n')
      52:	8a 45 00             	mov    0x0(%rbp),%al
      55:	3c 0a                	cmp    $0xa,%al
      57:	75 04                	jne    5d <mxml_write_ws+0x4b>
      59:	31 db                	xor    %ebx,%ebx
      5b:	eb 15                	jmp    72 <mxml_write_ws+0x60>
	col = 0;
      else if (*s == '\t')
      5d:	3c 09                	cmp    $0x9,%al
      5f:	75 0f                	jne    70 <mxml_write_ws+0x5e>
      {
	col += MXML_TAB;
      61:	8d 4b 08             	lea    0x8(%rbx),%ecx
	col = col - (col % MXML_TAB);
      64:	89 c8                	mov    %ecx,%eax
      66:	89 cb                	mov    %ecx,%ebx
      68:	99                   	cltd   
      69:	41 f7 fd             	idiv   %r13d
      6c:	29 d3                	sub    %edx,%ebx
      6e:	eb 02                	jmp    72 <mxml_write_ws+0x60>
      }
      else
	col ++;
      70:	ff c3                	inc    %ebx

      s ++;
      72:	48 ff c5             	inc    %rbp
  const char	*s;			/* Whitespace string */


  if (cb && (s = (*cb)(node, ws)) != NULL)
  {
    while (*s)
      75:	8a 45 00             	mov    0x0(%rbp),%al
      78:	84 c0                	test   %al,%al
      7a:	75 c4                	jne    40 <mxml_write_ws+0x2e>
      s ++;
    }
  }

  return (col);
}
      7c:	5a                   	pop    %rdx
      7d:	59                   	pop    %rcx
      7e:	89 d8                	mov    %ebx,%eax
      80:	5b                   	pop    %rbx
      81:	5d                   	pop    %rbp
      82:	41 5c                	pop    %r12
      84:	41 5d                	pop    %r13
      86:	41 5e                	pop    %r14
      88:	c3                   	retq   

0000000000000089 <mxmlSetWrapMargin>:
 * @since Mini-XML 2.3@
 */

void
mxmlSetWrapMargin(int column)		/* I - Column for wrapping, 0 to disable wrapping */
{
      89:	53                   	push   %rbx
      8a:	89 fb                	mov    %edi,%ebx
  _mxml_global_t *global = _mxml_global();
      8c:	e8 00 00 00 00       	callq  91 <mxmlSetWrapMargin+0x8>
					/* Global data */


  global->wrap = column;
      91:	89 98 30 03 00 00    	mov    %ebx,0x330(%rax)
}
      97:	5b                   	pop    %rbx
      98:	c3                   	retq   

0000000000000099 <mxmlSetErrorCallback>:
 * 'mxmlSetErrorCallback()' - Set the error message callback.
 */

void
mxmlSetErrorCallback(mxml_error_cb_t cb)/* I - Error callback function */
{
      99:	53                   	push   %rbx
      9a:	48 89 fb             	mov    %rdi,%rbx
  _mxml_global_t *global = _mxml_global();
      9d:	e8 00 00 00 00       	callq  a2 <mxmlSetErrorCallback+0x9>
					/* Global data */


  global->error_cb = cb;
      a2:	48 89 18             	mov    %rbx,(%rax)
}
      a5:	5b                   	pop    %rbx
      a6:	c3                   	retq   

00000000000000a7 <mxmlSetCustomHandlers>:

void
mxmlSetCustomHandlers(
    mxml_custom_load_cb_t load,		/* I - Load function */
    mxml_custom_save_cb_t save)		/* I - Save function */
{
      a7:	41 54                	push   %r12
      a9:	49 89 f4             	mov    %rsi,%r12
      ac:	53                   	push   %rbx
      ad:	48 89 fb             	mov    %rdi,%rbx
      b0:	48 83 ec 08          	sub    $0x8,%rsp
  _mxml_global_t *global = _mxml_global();
      b4:	e8 00 00 00 00       	callq  b9 <mxmlSetCustomHandlers+0x12>
					/* Global data */


  global->custom_load_cb = load;
      b9:	48 89 98 38 03 00 00 	mov    %rbx,0x338(%rax)
  global->custom_save_cb = save;
      c0:	4c 89 a0 40 03 00 00 	mov    %r12,0x340(%rax)
}
      c7:	5e                   	pop    %rsi
      c8:	5b                   	pop    %rbx
      c9:	41 5c                	pop    %r12
      cb:	c3                   	retq   

00000000000000cc <mxml_string_getc>:
 */

static int				/* O  - Character or EOF */
mxml_string_getc(void *p,		/* I  - Pointer to file */
                 int  *encoding)	/* IO - Encoding */
{
      cc:	48 83 ec 08          	sub    $0x8,%rsp
      d0:	49 89 f0             	mov    %rsi,%r8
  const char	**s;			/* Pointer to string pointer */


  s = (const char **)p;

  if ((ch = (*s)[0] & 255) != 0 || *encoding == ENCODE_UTF16LE)
      d3:	48 8b 0f             	mov    (%rdi),%rcx
      d6:	0f b6 31             	movzbl (%rcx),%esi
      d9:	85 f6                	test   %esi,%esi
      db:	75 0a                	jne    e7 <mxml_string_getc+0x1b>
      dd:	41 83 38 02          	cmpl   $0x2,(%r8)
      e1:	0f 85 ad 02 00 00    	jne    394 <mxml_string_getc+0x2c8>
    * Got character; convert UTF-8 to integer and return...
    */

    (*s)++;

    switch (*encoding)
      e7:	41 8b 00             	mov    (%r8),%eax
  {
   /*
    * Got character; convert UTF-8 to integer and return...
    */

    (*s)++;
      ea:	4c 8d 49 01          	lea    0x1(%rcx),%r9
      ee:	4c 89 0f             	mov    %r9,(%rdi)

    switch (*encoding)
      f1:	83 f8 01             	cmp    $0x1,%eax
      f4:	0f 84 b6 01 00 00    	je     2b0 <mxml_string_getc+0x1e4>
      fa:	83 f8 02             	cmp    $0x2,%eax
      fd:	0f 84 fe 01 00 00    	je     301 <mxml_string_getc+0x235>
     103:	85 c0                	test   %eax,%eax
     105:	0f 85 89 02 00 00    	jne    394 <mxml_string_getc+0x2c8>
    {
      case ENCODE_UTF8 :
	  if (!(ch & 0x80))
     10b:	40 84 f6             	test   %sil,%sil
     10e:	78 29                	js     139 <mxml_string_getc+0x6d>
	  {
#if DEBUG > 1
            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
#endif /* DEBUG > 1 */

	    if (mxml_bad_char(ch))
     110:	83 fe 1f             	cmp    $0x1f,%esi
     113:	0f 8f 7e 02 00 00    	jg     397 <mxml_string_getc+0x2cb>
     119:	83 fe 0a             	cmp    $0xa,%esi
     11c:	0f 84 75 02 00 00    	je     397 <mxml_string_getc+0x2cb>
     122:	83 fe 0d             	cmp    $0xd,%esi
     125:	0f 84 6c 02 00 00    	je     397 <mxml_string_getc+0x2cb>
     12b:	83 fe 09             	cmp    $0x9,%esi
     12e:	0f 85 fd 01 00 00    	jne    331 <mxml_string_getc+0x265>
     134:	e9 5e 02 00 00       	jmpq   397 <mxml_string_getc+0x2cb>
	      return (EOF);
	    }

	    return (ch);
          }
	  else if (ch == 0xfe)
     139:	81 fe fe 00 00 00    	cmp    $0xfe,%esi
     13f:	75 13                	jne    154 <mxml_string_getc+0x88>
	  {
	   /*
	    * UTF-16 big-endian BOM?
	    */

            if (((*s)[0] & 255) != 0xff)
     141:	80 79 01 ff          	cmpb   $0xff,0x1(%rcx)
     145:	0f 85 49 02 00 00    	jne    394 <mxml_string_getc+0x2c8>
	      return (EOF);

	    *encoding = ENCODE_UTF16BE;
     14b:	41 c7 00 01 00 00 00 	movl   $0x1,(%r8)
     152:	eb 19                	jmp    16d <mxml_string_getc+0xa1>
	    (*s)++;

	    return (mxml_string_getc(p, encoding));
	  }
	  else if (ch == 0xff)
     154:	81 fe ff 00 00 00    	cmp    $0xff,%esi
     15a:	75 19                	jne    175 <mxml_string_getc+0xa9>
	  {
	   /*
	    * UTF-16 little-endian BOM?
	    */

            if (((*s)[0] & 255) != 0xfe)
     15c:	80 79 01 fe          	cmpb   $0xfe,0x1(%rcx)
     160:	0f 85 2e 02 00 00    	jne    394 <mxml_string_getc+0x2c8>
	      return (EOF);

	    *encoding = ENCODE_UTF16LE;
     166:	41 c7 00 02 00 00 00 	movl   $0x2,(%r8)
	    (*s)++;
     16d:	48 ff 07             	incq   (%rdi)
     170:	e9 5e ff ff ff       	jmpq   d3 <mxml_string_getc+0x7>

	    return (mxml_string_getc(p, encoding));
	  }
	  else if ((ch & 0xe0) == 0xc0)
     175:	89 f0                	mov    %esi,%eax
     177:	25 e0 00 00 00       	and    $0xe0,%eax
     17c:	3d c0 00 00 00       	cmp    $0xc0,%eax
     181:	75 32                	jne    1b5 <mxml_string_getc+0xe9>
	  {
	   /*
	    * Two-byte value...
	    */

	    if (((*s)[0] & 0xc0) != 0x80)
     183:	41 0f be 11          	movsbl (%r9),%edx
     187:	89 d0                	mov    %edx,%eax
     189:	25 c0 00 00 00       	and    $0xc0,%eax
     18e:	83 c0 80             	add    $0xffffffffffffff80,%eax
     191:	0f 85 fd 01 00 00    	jne    394 <mxml_string_getc+0x2c8>
              return (EOF);

	    ch = ((ch & 0x1f) << 6) | ((*s)[0] & 0x3f);
     197:	89 f0                	mov    %esi,%eax
     199:	89 d6                	mov    %edx,%esi
     19b:	83 e0 1f             	and    $0x1f,%eax
     19e:	83 e6 3f             	and    $0x3f,%esi
     1a1:	c1 e0 06             	shl    $0x6,%eax
     1a4:	09 c6                	or     %eax,%esi

	    (*s)++;
     1a6:	48 8d 41 02          	lea    0x2(%rcx),%rax

	    if (ch < 0x80)
     1aa:	83 fe 7f             	cmp    $0x7f,%esi
	    if (((*s)[0] & 0xc0) != 0x80)
              return (EOF);

	    ch = ((ch & 0x1f) << 6) | ((*s)[0] & 0x3f);

	    (*s)++;
     1ad:	48 89 07             	mov    %rax,(%rdi)
     1b0:	e9 e9 00 00 00       	jmpq   29e <mxml_string_getc+0x1d2>
            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
#endif /* DEBUG > 1 */

	    return (ch);
	  }
	  else if ((ch & 0xf0) == 0xe0)
     1b5:	89 f0                	mov    %esi,%eax
     1b7:	25 f0 00 00 00       	and    $0xf0,%eax
     1bc:	3d e0 00 00 00       	cmp    $0xe0,%eax
     1c1:	75 60                	jne    223 <mxml_string_getc+0x157>
	  {
	   /*
	    * Three-byte value...
	    */

	    if (((*s)[0] & 0xc0) != 0x80 ||
     1c3:	0f be 49 01          	movsbl 0x1(%rcx),%ecx
     1c7:	89 c8                	mov    %ecx,%eax
     1c9:	25 c0 00 00 00       	and    $0xc0,%eax
     1ce:	83 c0 80             	add    $0xffffffffffffff80,%eax
     1d1:	0f 85 bd 01 00 00    	jne    394 <mxml_string_getc+0x2c8>
     1d7:	41 0f be 51 01       	movsbl 0x1(%r9),%edx
     1dc:	89 d0                	mov    %edx,%eax
     1de:	25 c0 00 00 00       	and    $0xc0,%eax
     1e3:	83 c0 80             	add    $0xffffffffffffff80,%eax
     1e6:	0f 85 a8 01 00 00    	jne    394 <mxml_string_getc+0x2c8>
        	((*s)[1] & 0xc0) != 0x80)
              return (EOF);

	    ch = ((((ch & 0x0f) << 6) | ((*s)[0] & 0x3f)) << 6) | ((*s)[1] & 0x3f);
     1ec:	83 e6 0f             	and    $0xf,%esi
     1ef:	83 e1 3f             	and    $0x3f,%ecx
     1f2:	83 e2 3f             	and    $0x3f,%edx
     1f5:	c1 e6 06             	shl    $0x6,%esi

	    (*s) += 2;
     1f8:	49 8d 41 02          	lea    0x2(%r9),%rax

	    if (((*s)[0] & 0xc0) != 0x80 ||
        	((*s)[1] & 0xc0) != 0x80)
              return (EOF);

	    ch = ((((ch & 0x0f) << 6) | ((*s)[0] & 0x3f)) << 6) | ((*s)[1] & 0x3f);
     1fc:	09 ce                	or     %ecx,%esi
     1fe:	c1 e6 06             	shl    $0x6,%esi

	    (*s) += 2;
     201:	48 89 07             	mov    %rax,(%rdi)

	    if (((*s)[0] & 0xc0) != 0x80 ||
        	((*s)[1] & 0xc0) != 0x80)
              return (EOF);

	    ch = ((((ch & 0x0f) << 6) | ((*s)[0] & 0x3f)) << 6) | ((*s)[1] & 0x3f);
     204:	09 d6                	or     %edx,%esi

	    (*s) += 2;

	    if (ch < 0x800)
     206:	81 fe ff 07 00 00    	cmp    $0x7ff,%esi
     20c:	0f 8e 92 00 00 00    	jle    2a4 <mxml_string_getc+0x1d8>

	   /*
	    * Ignore (strip) Byte Order Mark (BOM)...
	    */

	    if (ch == 0xfeff)
     212:	81 fe ff fe 00 00    	cmp    $0xfeff,%esi
     218:	0f 84 b5 fe ff ff    	je     d3 <mxml_string_getc+0x7>
     21e:	e9 74 01 00 00       	jmpq   397 <mxml_string_getc+0x2cb>
            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
#endif /* DEBUG > 1 */

	    return (ch);
	  }
	  else if ((ch & 0xf8) == 0xf0)
     223:	89 f0                	mov    %esi,%eax
     225:	25 f8 00 00 00       	and    $0xf8,%eax
     22a:	3d f0 00 00 00       	cmp    $0xf0,%eax
     22f:	0f 85 5f 01 00 00    	jne    394 <mxml_string_getc+0x2c8>
	  {
	   /*
	    * Four-byte value...
	    */

	    if (((*s)[0] & 0xc0) != 0x80 ||
     235:	45 0f be 01          	movsbl (%r9),%r8d
     239:	44 89 c0             	mov    %r8d,%eax
     23c:	25 c0 00 00 00       	and    $0xc0,%eax
     241:	83 c0 80             	add    $0xffffffffffffff80,%eax
     244:	0f 85 4a 01 00 00    	jne    394 <mxml_string_getc+0x2c8>
     24a:	41 0f be 49 01       	movsbl 0x1(%r9),%ecx
     24f:	89 c8                	mov    %ecx,%eax
     251:	25 c0 00 00 00       	and    $0xc0,%eax
     256:	83 c0 80             	add    $0xffffffffffffff80,%eax
     259:	0f 85 35 01 00 00    	jne    394 <mxml_string_getc+0x2c8>
     25f:	41 0f be 51 02       	movsbl 0x2(%r9),%edx
     264:	89 d0                	mov    %edx,%eax
     266:	25 c0 00 00 00       	and    $0xc0,%eax
     26b:	83 c0 80             	add    $0xffffffffffffff80,%eax
     26e:	0f 85 20 01 00 00    	jne    394 <mxml_string_getc+0x2c8>
        	((*s)[1] & 0xc0) != 0x80 ||
        	((*s)[2] & 0xc0) != 0x80)
              return (EOF);

	    ch = ((((((ch & 0x07) << 6) | ((*s)[0] & 0x3f)) << 6) |
     274:	83 e6 07             	and    $0x7,%esi
     277:	41 83 e0 3f          	and    $0x3f,%r8d
     27b:	83 e1 3f             	and    $0x3f,%ecx
     27e:	c1 e6 06             	shl    $0x6,%esi
     281:	83 e2 3f             	and    $0x3f,%edx
        	   ((*s)[1] & 0x3f)) << 6) | ((*s)[2] & 0x3f);

	    (*s) += 3;
     284:	49 8d 41 03          	lea    0x3(%r9),%rax
	    if (((*s)[0] & 0xc0) != 0x80 ||
        	((*s)[1] & 0xc0) != 0x80 ||
        	((*s)[2] & 0xc0) != 0x80)
              return (EOF);

	    ch = ((((((ch & 0x07) << 6) | ((*s)[0] & 0x3f)) << 6) |
     288:	44 09 c6             	or     %r8d,%esi
     28b:	c1 e6 06             	shl    $0x6,%esi
        	   ((*s)[1] & 0x3f)) << 6) | ((*s)[2] & 0x3f);

	    (*s) += 3;
     28e:	48 89 07             	mov    %rax,(%rdi)
	    if (((*s)[0] & 0xc0) != 0x80 ||
        	((*s)[1] & 0xc0) != 0x80 ||
        	((*s)[2] & 0xc0) != 0x80)
              return (EOF);

	    ch = ((((((ch & 0x07) << 6) | ((*s)[0] & 0x3f)) << 6) |
     291:	09 ce                	or     %ecx,%esi
     293:	c1 e6 06             	shl    $0x6,%esi
     296:	09 d6                	or     %edx,%esi
        	   ((*s)[1] & 0x3f)) << 6) | ((*s)[2] & 0x3f);

	    (*s) += 3;

	    if (ch < 0x10000)
     298:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
     29e:	0f 8f f3 00 00 00    	jg     397 <mxml_string_getc+0x2cb>
	    {
	      mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
     2a4:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 2ab <mxml_string_getc+0x1df>
     2ab:	e9 88 00 00 00       	jmpq   338 <mxml_string_getc+0x26c>
      case ENCODE_UTF16BE :
	 /*
          * Read UTF-16 big-endian char...
	  */

	  ch = (ch << 8) | ((*s)[0] & 255);
     2b0:	89 f0                	mov    %esi,%eax
     2b2:	41 0f b6 31          	movzbl (%r9),%esi
	  (*s) ++;
     2b6:	4c 8d 41 02          	lea    0x2(%rcx),%r8
      case ENCODE_UTF16BE :
	 /*
          * Read UTF-16 big-endian char...
	  */

	  ch = (ch << 8) | ((*s)[0] & 255);
     2ba:	c1 e0 08             	shl    $0x8,%eax
	  (*s) ++;
     2bd:	4c 89 07             	mov    %r8,(%rdi)
      case ENCODE_UTF16BE :
	 /*
          * Read UTF-16 big-endian char...
	  */

	  ch = (ch << 8) | ((*s)[0] & 255);
     2c0:	09 c6                	or     %eax,%esi
	  (*s) ++;

          if (mxml_bad_char(ch))
     2c2:	83 fe 1f             	cmp    $0x1f,%esi
     2c5:	7f 0f                	jg     2d6 <mxml_string_getc+0x20a>
     2c7:	83 fe 0a             	cmp    $0xa,%esi
     2ca:	74 0a                	je     2d6 <mxml_string_getc+0x20a>
     2cc:	83 fe 0d             	cmp    $0xd,%esi
     2cf:	74 05                	je     2d6 <mxml_string_getc+0x20a>
     2d1:	83 fe 09             	cmp    $0x9,%esi
     2d4:	75 5b                	jne    331 <mxml_string_getc+0x265>
	  {
	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
        	       ch);
	    return (EOF);
	  }
          else if (ch >= 0xd800 && ch <= 0xdbff)
     2d6:	8d 86 00 28 ff ff    	lea    -0xd800(%rsi),%eax
     2dc:	3d ff 03 00 00       	cmp    $0x3ff,%eax
     2e1:	0f 87 b0 00 00 00    	ja     397 <mxml_string_getc+0x2cb>
	    */

            int lch;			/* Lower word */


            if (!(*s)[0])
     2e7:	8a 41 02             	mov    0x2(%rcx),%al
     2ea:	84 c0                	test   %al,%al
     2ec:	0f 84 a2 00 00 00    	je     394 <mxml_string_getc+0x2c8>
	      return (EOF);

            lch = (((*s)[0] & 255) << 8) | ((*s)[1] & 255);
     2f2:	c1 e0 08             	shl    $0x8,%eax
     2f5:	41 0f b6 50 01       	movzbl 0x1(%r8),%edx
     2fa:	25 00 ff 00 00       	and    $0xff00,%eax
     2ff:	eb 64                	jmp    365 <mxml_string_getc+0x299>
      case ENCODE_UTF16LE :
	 /*
          * Read UTF-16 little-endian char...
	  */

	  ch = ch | (((*s)[0] & 255) << 8);
     301:	41 0f be 01          	movsbl (%r9),%eax
     305:	c1 e0 08             	shl    $0x8,%eax
     308:	25 ff ff 00 00       	and    $0xffff,%eax

	  if (!ch)
     30d:	09 c6                	or     %eax,%esi
     30f:	75 05                	jne    316 <mxml_string_getc+0x24a>
	  {
	    (*s) --;
     311:	48 89 0f             	mov    %rcx,(%rdi)
     314:	eb 7e                	jmp    394 <mxml_string_getc+0x2c8>
	    return (EOF);
	  }

	  (*s) ++;
     316:	4c 8d 41 02          	lea    0x2(%rcx),%r8

          if (mxml_bad_char(ch))
     31a:	83 fe 1f             	cmp    $0x1f,%esi
	  {
	    (*s) --;
	    return (EOF);
	  }

	  (*s) ++;
     31d:	4c 89 07             	mov    %r8,(%rdi)

          if (mxml_bad_char(ch))
     320:	7f 1f                	jg     341 <mxml_string_getc+0x275>
     322:	83 fe 0a             	cmp    $0xa,%esi
     325:	74 1a                	je     341 <mxml_string_getc+0x275>
     327:	83 fe 0d             	cmp    $0xd,%esi
     32a:	74 15                	je     341 <mxml_string_getc+0x275>
     32c:	83 fe 09             	cmp    $0x9,%esi
     32f:	74 10                	je     341 <mxml_string_getc+0x275>
	  {
	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
     331:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 338 <mxml_string_getc+0x26c>
     338:	31 c0                	xor    %eax,%eax
     33a:	e8 00 00 00 00       	callq  33f <mxml_string_getc+0x273>
     33f:	eb 53                	jmp    394 <mxml_string_getc+0x2c8>
        	       ch);
	    return (EOF);
	  }
          else if (ch >= 0xd800 && ch <= 0xdbff)
     341:	8d 86 00 28 ff ff    	lea    -0xd800(%rsi),%eax
     347:	3d ff 03 00 00       	cmp    $0x3ff,%eax
     34c:	77 49                	ja     397 <mxml_string_getc+0x2cb>
	    */

            int lch;			/* Lower word */


            if (!(*s)[1])
     34e:	41 8a 40 01          	mov    0x1(%r8),%al
     352:	84 c0                	test   %al,%al
     354:	74 3e                	je     394 <mxml_string_getc+0x2c8>
	      return (EOF);

            lch = (((*s)[1] & 255) << 8) | ((*s)[0] & 255);
     356:	89 c2                	mov    %eax,%edx
     358:	0f b6 41 02          	movzbl 0x2(%rcx),%eax
     35c:	c1 e2 08             	shl    $0x8,%edx
     35f:	81 e2 00 ff 00 00    	and    $0xff00,%edx
     365:	09 c2                	or     %eax,%edx
	    (*s) += 2;
     367:	49 8d 40 02          	lea    0x2(%r8),%rax
     36b:	48 89 07             	mov    %rax,(%rdi)

            if (lch < 0xdc00 || lch >= 0xdfff)
     36e:	8d 82 00 24 ff ff    	lea    -0xdc00(%rdx),%eax
     374:	3d fe 03 00 00       	cmp    $0x3fe,%eax
     379:	77 19                	ja     394 <mxml_string_getc+0x2c8>
	      return (EOF);

            ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
     37b:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
     381:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
     387:	c1 e6 0a             	shl    $0xa,%esi
     38a:	09 f2                	or     %esi,%edx
     38c:	8d b2 00 00 01 00    	lea    0x10000(%rdx),%esi
     392:	eb 03                	jmp    397 <mxml_string_getc+0x2cb>
     394:	83 ce ff             	or     $0xffffffffffffffff,%esi
	  return (ch);
    }
  }

  return (EOF);
}
     397:	89 f0                	mov    %esi,%eax
     399:	5f                   	pop    %rdi
     39a:	c3                   	retq   

000000000000039b <mxml_get_entity>:
mxml_get_entity(mxml_node_t *parent,	/* I  - Parent node */
		void        *p,		/* I  - Pointer to source */
		int         *encoding,	/* IO - Character encoding */
                int         (*getc_cb)(void *, int *))
					/* I  - Get character function */
{
     39b:	41 57                	push   %r15
     39d:	49 89 d7             	mov    %rdx,%r15
     3a0:	41 56                	push   %r14
     3a2:	49 89 ce             	mov    %rcx,%r14
     3a5:	41 55                	push   %r13
     3a7:	41 54                	push   %r12
     3a9:	49 89 fc             	mov    %rdi,%r12
     3ac:	55                   	push   %rbp
     3ad:	53                   	push   %rbx
     3ae:	48 83 ec 58          	sub    $0x58,%rsp
     3b2:	48 8d 6c 24 10       	lea    0x10(%rsp),%rbp
     3b7:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  entptr = entity;

  while ((ch = (*getc_cb)(p, encoding)) != EOF)
    if (ch > 126 || (!isalnum(ch) && ch != '#'))
      break;
    else if (entptr < (entity + sizeof(entity) - 1))
     3bc:	4c 8d 6d 3f          	lea    0x3f(%rbp),%r13
     3c0:	eb 49                	jmp    40b <mxml_get_entity+0x70>


  entptr = entity;

  while ((ch = (*getc_cb)(p, encoding)) != EOF)
    if (ch > 126 || (!isalnum(ch) && ch != '#'))
     3c2:	83 fb 7e             	cmp    $0x7e,%ebx
     3c5:	7f 56                	jg     41d <mxml_get_entity+0x82>
     3c7:	e8 00 00 00 00       	callq  3cc <mxml_get_entity+0x31>
     3cc:	48 8b 00             	mov    (%rax),%rax
     3cf:	48 63 d3             	movslq %ebx,%rdx
     3d2:	f6 04 50 08          	testb  $0x8,(%rax,%rdx,2)
     3d6:	75 05                	jne    3dd <mxml_get_entity+0x42>
     3d8:	83 fb 23             	cmp    $0x23,%ebx
     3db:	75 40                	jne    41d <mxml_get_entity+0x82>
      break;
    else if (entptr < (entity + sizeof(entity) - 1))
     3dd:	4c 39 ed             	cmp    %r13,%rbp
     3e0:	74 08                	je     3ea <mxml_get_entity+0x4f>
      *entptr++ = ch;
     3e2:	88 5d 00             	mov    %bl,0x0(%rbp)
     3e5:	48 ff c5             	inc    %rbp
     3e8:	eb 21                	jmp    40b <mxml_get_entity+0x70>
    else
    {
      mxml_error("Entity name too long under parent <%s>!",
     3ea:	4d 85 e4             	test   %r12,%r12
     3ed:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # 3f4 <mxml_get_entity+0x59>
     3f4:	74 05                	je     3fb <mxml_get_entity+0x60>
     3f6:	49 8b 74 24 30       	mov    0x30(%r12),%rsi
     3fb:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 402 <mxml_get_entity+0x67>
     402:	31 c0                	xor    %eax,%eax
     404:	e8 00 00 00 00       	callq  409 <mxml_get_entity+0x6e>
     409:	eb 12                	jmp    41d <mxml_get_entity+0x82>
	*entptr;			/* Pointer into entity */


  entptr = entity;

  while ((ch = (*getc_cb)(p, encoding)) != EOF)
     40b:	4c 89 fe             	mov    %r15,%rsi
     40e:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
     413:	41 ff d6             	callq  *%r14
     416:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     419:	89 c3                	mov    %eax,%ebx
     41b:	75 a5                	jne    3c2 <mxml_get_entity+0x27>
      break;
    }

  *entptr = '\0';

  if (ch != ';')
     41d:	83 fb 3b             	cmp    $0x3b,%ebx
      mxml_error("Entity name too long under parent <%s>!",
	         parent ? parent->value.element.name : "null");
      break;
    }

  *entptr = '\0';
     420:	c6 45 00 00          	movb   $0x0,0x0(%rbp)

  if (ch != ';')
     424:	74 29                	je     44f <mxml_get_entity+0xb4>
  {
    mxml_error("Character entity \"%s\" not terminated under parent <%s>!",
     426:	4d 85 e4             	test   %r12,%r12
     429:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 430 <mxml_get_entity+0x95>
     430:	74 05                	je     437 <mxml_get_entity+0x9c>
     432:	49 8b 54 24 30       	mov    0x30(%r12),%rdx
     437:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
     43c:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 443 <mxml_get_entity+0xa8>
     443:	31 c0                	xor    %eax,%eax
     445:	e8 00 00 00 00       	callq  44a <mxml_get_entity+0xaf>
     44a:	e9 9b 00 00 00       	jmpq   4ea <mxml_get_entity+0x14f>
	       entity, parent ? parent->value.element.name : "null");
    return (EOF);
  }

  if (entity[0] == '#')
     44f:	80 7c 24 10 23       	cmpb   $0x23,0x10(%rsp)
     454:	75 2b                	jne    481 <mxml_get_entity+0xe6>
  {
    if (entity[1] == 'x')
     456:	80 7c 24 11 78       	cmpb   $0x78,0x11(%rsp)
     45b:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
     460:	75 0b                	jne    46d <mxml_get_entity+0xd2>
      ch = strtol(entity + 2, NULL, 16);
     462:	48 8d 78 02          	lea    0x2(%rax),%rdi
     466:	ba 10 00 00 00       	mov    $0x10,%edx
     46b:	eb 09                	jmp    476 <mxml_get_entity+0xdb>
    else
      ch = strtol(entity + 1, NULL, 10);
     46d:	48 8d 78 01          	lea    0x1(%rax),%rdi
     471:	ba 0a 00 00 00       	mov    $0xa,%edx
     476:	31 f6                	xor    %esi,%esi
     478:	e8 00 00 00 00       	callq  47d <mxml_get_entity+0xe2>
     47d:	89 c3                	mov    %eax,%ebx
     47f:	eb 34                	jmp    4b5 <mxml_get_entity+0x11a>
  }
  else if ((ch = mxmlEntityGetValue(entity)) < 0)
     481:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
     486:	e8 00 00 00 00       	callq  48b <mxml_get_entity+0xf0>
     48b:	85 c0                	test   %eax,%eax
     48d:	89 c3                	mov    %eax,%ebx
     48f:	79 24                	jns    4b5 <mxml_get_entity+0x11a>
    mxml_error("Entity name \"%s;\" not supported under parent <%s>!",
     491:	4d 85 e4             	test   %r12,%r12
     494:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 49b <mxml_get_entity+0x100>
     49b:	74 05                	je     4a2 <mxml_get_entity+0x107>
     49d:	49 8b 54 24 30       	mov    0x30(%r12),%rdx
     4a2:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
     4a7:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 4ae <mxml_get_entity+0x113>
     4ae:	31 c0                	xor    %eax,%eax
     4b0:	e8 00 00 00 00       	callq  4b5 <mxml_get_entity+0x11a>
	       entity, parent ? parent->value.element.name : "null");

  if (mxml_bad_char(ch))
     4b5:	83 fb 1f             	cmp    $0x1f,%ebx
     4b8:	7f 33                	jg     4ed <mxml_get_entity+0x152>
     4ba:	83 fb 0a             	cmp    $0xa,%ebx
     4bd:	74 2e                	je     4ed <mxml_get_entity+0x152>
     4bf:	83 fb 0d             	cmp    $0xd,%ebx
     4c2:	74 29                	je     4ed <mxml_get_entity+0x152>
     4c4:	83 fb 09             	cmp    $0x9,%ebx
     4c7:	74 24                	je     4ed <mxml_get_entity+0x152>
  {
    mxml_error("Bad control character 0x%02x under parent <%s> not allowed by XML standard!",
     4c9:	4d 85 e4             	test   %r12,%r12
     4cc:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 4d3 <mxml_get_entity+0x138>
     4d3:	74 05                	je     4da <mxml_get_entity+0x13f>
     4d5:	49 8b 54 24 30       	mov    0x30(%r12),%rdx
     4da:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 4e1 <mxml_get_entity+0x146>
     4e1:	89 de                	mov    %ebx,%esi
     4e3:	31 c0                	xor    %eax,%eax
     4e5:	e8 00 00 00 00       	callq  4ea <mxml_get_entity+0x14f>
     4ea:	83 cb ff             	or     $0xffffffffffffffff,%ebx
               ch, parent ? parent->value.element.name : "null");
    return (EOF);
  }

  return (ch);
}
     4ed:	48 83 c4 58          	add    $0x58,%rsp
     4f1:	89 d8                	mov    %ebx,%eax
     4f3:	5b                   	pop    %rbx
     4f4:	5d                   	pop    %rbp
     4f5:	41 5c                	pop    %r12
     4f7:	41 5d                	pop    %r13
     4f9:	41 5e                	pop    %r14
     4fb:	41 5f                	pop    %r15
     4fd:	c3                   	retq   

00000000000004fe <mxml_add_char>:
static int				/* O  - 0 on success, -1 on error */
mxml_add_char(int  ch,			/* I  - Character to add */
              char **bufptr,		/* IO - Current position in buffer */
	      char **buffer,		/* IO - Current buffer */
	      int  *bufsize)		/* IO - Current buffer size */
{
     4fe:	41 55                	push   %r13
     500:	49 89 f5             	mov    %rsi,%r13
     503:	41 54                	push   %r12
     505:	49 89 d4             	mov    %rdx,%r12
     508:	55                   	push   %rbp
     509:	48 89 cd             	mov    %rcx,%rbp
     50c:	53                   	push   %rbx
     50d:	89 fb                	mov    %edi,%ebx
     50f:	48 83 ec 08          	sub    $0x8,%rsp
  char	*newbuffer;			/* New buffer value */


  if (*bufptr >= (*buffer + *bufsize - 4))
     513:	8b 11                	mov    (%rcx),%edx
     515:	48 63 c2             	movslq %edx,%rax
     518:	48 83 e8 04          	sub    $0x4,%rax
     51c:	49 03 04 24          	add    (%r12),%rax
     520:	48 39 06             	cmp    %rax,(%rsi)
     523:	72 5b                	jb     580 <mxml_add_char+0x82>
  {
   /*
    * Increase the size of the buffer...
    */

    if (*bufsize < 1024)
     525:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
      (*bufsize) *= 2;
     52b:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
  {
   /*
    * Increase the size of the buffer...
    */

    if (*bufsize < 1024)
     52e:	7e 06                	jle    536 <mxml_add_char+0x38>
      (*bufsize) *= 2;
    else
      (*bufsize) += 1024;
     530:	8d 82 00 04 00 00    	lea    0x400(%rdx),%eax
     536:	89 45 00             	mov    %eax,0x0(%rbp)

    if ((newbuffer = realloc(*buffer, *bufsize)) == NULL)
     539:	48 63 75 00          	movslq 0x0(%rbp),%rsi
     53d:	49 8b 3c 24          	mov    (%r12),%rdi
     541:	e8 00 00 00 00       	callq  546 <mxml_add_char+0x48>
     546:	48 85 c0             	test   %rax,%rax
     549:	48 89 c2             	mov    %rax,%rdx
     54c:	75 22                	jne    570 <mxml_add_char+0x72>
    {
      free(*buffer);
     54e:	49 8b 3c 24          	mov    (%r12),%rdi
     552:	e8 00 00 00 00       	callq  557 <mxml_add_char+0x59>

      mxml_error("Unable to expand string buffer to %d bytes!", *bufsize);
     557:	8b 75 00             	mov    0x0(%rbp),%esi
     55a:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 561 <mxml_add_char+0x63>
     561:	31 c0                	xor    %eax,%eax
     563:	e8 00 00 00 00       	callq  568 <mxml_add_char+0x6a>
     568:	83 c8 ff             	or     $0xffffffffffffffff,%eax
     56b:	e9 ba 00 00 00       	jmpq   62a <mxml_add_char+0x12c>

      return (-1);
    }

    *bufptr = newbuffer + (*bufptr - *buffer);
     570:	49 03 45 00          	add    0x0(%r13),%rax
     574:	49 2b 04 24          	sub    (%r12),%rax
     578:	49 89 45 00          	mov    %rax,0x0(%r13)
    *buffer = newbuffer;
     57c:	49 89 14 24          	mov    %rdx,(%r12)
  }

  if (ch < 0x80)
     580:	83 fb 7f             	cmp    $0x7f,%ebx
     583:	7f 0e                	jg     593 <mxml_add_char+0x95>
  {
   /*
    * Single byte ASCII...
    */

    *(*bufptr)++ = ch;
     585:	49 8b 45 00          	mov    0x0(%r13),%rax
     589:	88 18                	mov    %bl,(%rax)
     58b:	48 ff c0             	inc    %rax
     58e:	e9 91 00 00 00       	jmpq   624 <mxml_add_char+0x126>
  }
  else if (ch < 0x800)
     593:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
     599:	7f 1f                	jg     5ba <mxml_add_char+0xbc>
  {
   /*
    * Two-byte UTF-8...
    */

    *(*bufptr)++ = 0xc0 | (ch >> 6);
     59b:	49 8b 45 00          	mov    0x0(%r13),%rax
     59f:	89 da                	mov    %ebx,%edx
     5a1:	c1 fa 06             	sar    $0x6,%edx
     5a4:	83 ca c0             	or     $0xffffffffffffffc0,%edx
     5a7:	88 10                	mov    %dl,(%rax)
    *(*bufptr)++ = 0x80 | (ch & 0x3f);
     5a9:	88 da                	mov    %bl,%dl
     5ab:	83 e2 3f             	and    $0x3f,%edx
     5ae:	83 ca 80             	or     $0xffffffffffffff80,%edx
     5b1:	88 50 01             	mov    %dl,0x1(%rax)
     5b4:	48 83 c0 02          	add    $0x2,%rax
     5b8:	eb 6a                	jmp    624 <mxml_add_char+0x126>
  }
  else if (ch < 0x10000)
     5ba:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
     5c0:	49 8b 55 00          	mov    0x0(%r13),%rdx
     5c4:	7f 29                	jg     5ef <mxml_add_char+0xf1>
  {
   /*
    * Three-byte UTF-8...
    */

    *(*bufptr)++ = 0xe0 | (ch >> 12);
     5c6:	89 d8                	mov    %ebx,%eax
     5c8:	c1 f8 0c             	sar    $0xc,%eax
     5cb:	83 c8 e0             	or     $0xffffffffffffffe0,%eax
     5ce:	88 02                	mov    %al,(%rdx)
    *(*bufptr)++ = 0x80 | ((ch >> 6) & 0x3f);
     5d0:	89 d8                	mov    %ebx,%eax
     5d2:	c1 f8 06             	sar    $0x6,%eax
     5d5:	83 e0 3f             	and    $0x3f,%eax
     5d8:	83 c8 80             	or     $0xffffffffffffff80,%eax
     5db:	88 42 01             	mov    %al,0x1(%rdx)
    *(*bufptr)++ = 0x80 | (ch & 0x3f);
     5de:	88 d8                	mov    %bl,%al
     5e0:	83 e0 3f             	and    $0x3f,%eax
     5e3:	83 c8 80             	or     $0xffffffffffffff80,%eax
     5e6:	88 42 02             	mov    %al,0x2(%rdx)
     5e9:	48 8d 42 03          	lea    0x3(%rdx),%rax
     5ed:	eb 35                	jmp    624 <mxml_add_char+0x126>
  {
   /*
    * Four-byte UTF-8...
    */

    *(*bufptr)++ = 0xf0 | (ch >> 18);
     5ef:	89 d8                	mov    %ebx,%eax
     5f1:	c1 f8 12             	sar    $0x12,%eax
     5f4:	83 c8 f0             	or     $0xfffffffffffffff0,%eax
     5f7:	88 02                	mov    %al,(%rdx)
    *(*bufptr)++ = 0x80 | ((ch >> 12) & 0x3f);
     5f9:	89 d8                	mov    %ebx,%eax
     5fb:	c1 f8 0c             	sar    $0xc,%eax
     5fe:	83 e0 3f             	and    $0x3f,%eax
     601:	83 c8 80             	or     $0xffffffffffffff80,%eax
     604:	88 42 01             	mov    %al,0x1(%rdx)
    *(*bufptr)++ = 0x80 | ((ch >> 6) & 0x3f);
     607:	89 d8                	mov    %ebx,%eax
     609:	c1 f8 06             	sar    $0x6,%eax
     60c:	83 e0 3f             	and    $0x3f,%eax
     60f:	83 c8 80             	or     $0xffffffffffffff80,%eax
     612:	88 42 02             	mov    %al,0x2(%rdx)
    *(*bufptr)++ = 0x80 | (ch & 0x3f);
     615:	88 d8                	mov    %bl,%al
     617:	83 e0 3f             	and    $0x3f,%eax
     61a:	83 c8 80             	or     $0xffffffffffffff80,%eax
     61d:	88 42 03             	mov    %al,0x3(%rdx)
     620:	48 8d 42 04          	lea    0x4(%rdx),%rax
     624:	49 89 45 00          	mov    %rax,0x0(%r13)
     628:	31 c0                	xor    %eax,%eax
  }

  return (0);
}
     62a:	41 58                	pop    %r8
     62c:	5b                   	pop    %rbx
     62d:	5d                   	pop    %rbp
     62e:	41 5c                	pop    %r12
     630:	41 5d                	pop    %r13
     632:	c3                   	retq   

0000000000000633 <mxml_load_data>:
    void            *p,			/* I - Pointer to data */
    mxml_load_cb_t  cb,			/* I - Callback function or MXML_NO_CALLBACK */
    _mxml_getc_cb_t getc_cb,		/* I - Read function */
    mxml_sax_cb_t   sax_cb,		/* I - SAX callback or MXML_NO_CALLBACK */
    void            *sax_data)		/* I - SAX user data */
{
     633:	41 57                	push   %r15
     635:	49 89 cf             	mov    %rcx,%r15
     638:	41 56                	push   %r14
     63a:	41 55                	push   %r13
     63c:	41 54                	push   %r12
     63e:	55                   	push   %rbp
     63f:	53                   	push   %rbx
     640:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
     647:	48 89 7c 24 78       	mov    %rdi,0x78(%rsp)
     64c:	48 89 74 24 70       	mov    %rsi,0x70(%rsp)
     651:	48 89 54 24 68       	mov    %rdx,0x68(%rsp)
     656:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
     65b:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
  char		*buffer,		/* String buffer */
		*bufptr;		/* Pointer into buffer */
  int		bufsize;		/* Size of buffer */
  mxml_type_t	type;			/* Current node type */
  int		encoding;		/* Character encoding */
  _mxml_global_t *global = _mxml_global();
     660:	e8 00 00 00 00       	callq  665 <mxml_load_data+0x32>

 /*
  * Read elements and other nodes from the file...
  */

  if ((buffer = malloc(64)) == NULL)
     665:	bf 40 00 00 00       	mov    $0x40,%edi
  char		*buffer,		/* String buffer */
		*bufptr;		/* Pointer into buffer */
  int		bufsize;		/* Size of buffer */
  mxml_type_t	type;			/* Current node type */
  int		encoding;		/* Character encoding */
  _mxml_global_t *global = _mxml_global();
     66a:	48 89 84 24 90 00 00 	mov    %rax,0x90(%rsp)
     671:	00 

 /*
  * Read elements and other nodes from the file...
  */

  if ((buffer = malloc(64)) == NULL)
     672:	e8 00 00 00 00       	callq  677 <mxml_load_data+0x44>
     677:	48 85 c0             	test   %rax,%rax
     67a:	48 89 84 24 c0 00 00 	mov    %rax,0xc0(%rsp)
     681:	00 
     682:	75 11                	jne    695 <mxml_load_data+0x62>
  {
    mxml_error("Unable to allocate string buffer!");
     684:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 68b <mxml_load_data+0x58>
     68b:	e8 00 00 00 00       	callq  690 <mxml_load_data+0x5d>
     690:	e9 0f 11 00 00       	jmpq   17a4 <mxml_load_data+0x1171>
  parent     = top;
  first      = NULL;
  whitespace = 0;
  encoding   = ENCODE_UTF8;

  if (cb && parent)
     695:	48 83 7c 24 68 00    	cmpq   $0x0,0x68(%rsp)
    mxml_error("Unable to allocate string buffer!");
    return (NULL);
  }

  bufsize    = 64;
  bufptr     = buffer;
     69b:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
     6a2:	00 
  {
    mxml_error("Unable to allocate string buffer!");
    return (NULL);
  }

  bufsize    = 64;
     6a3:	c7 84 24 d4 00 00 00 	movl   $0x40,0xd4(%rsp)
     6aa:	40 00 00 00 
  bufptr     = buffer;
  parent     = top;
  first      = NULL;
  whitespace = 0;
  encoding   = ENCODE_UTF8;
     6ae:	c7 84 24 d0 00 00 00 	movl   $0x0,0xd0(%rsp)
     6b5:	00 00 00 00 

  if (cb && parent)
     6b9:	0f 95 84 24 87 00 00 	setne  0x87(%rsp)
     6c0:	00 
     6c1:	48 83 7c 24 78 00    	cmpq   $0x0,0x78(%rsp)
     6c7:	0f 95 c0             	setne  %al
     6ca:	80 bc 24 87 00 00 00 	cmpb   $0x0,0x87(%rsp)
     6d1:	00 
     6d2:	74 60                	je     734 <mxml_load_data+0x101>
     6d4:	84 c0                	test   %al,%al
     6d6:	74 6b                	je     743 <mxml_load_data+0x110>
    type = (*cb)(parent);
     6d8:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
     6dd:	ff 54 24 68          	callq  *0x68(%rsp)
     6e1:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%rsp)
  else if (parent)
    type = MXML_TEXT;
  else
    type = MXML_IGNORE;

  while ((ch = (*getc_cb)(p, &encoding)) != EOF)
     6e8:	48 8d 84 24 d0 00 00 	lea    0xd0(%rsp),%rax
     6ef:	00 
      {
        if (ch == '&')
	  if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
	    goto error;

	if (mxml_add_char(ch, &ptr, &name, &namesize))
     6f0:	48 8d 94 24 cc 00 00 	lea    0xcc(%rsp),%rdx
     6f7:	00 
  first      = NULL;
  whitespace = 0;
  encoding   = ENCODE_UTF8;

  if (cb && parent)
    type = (*cb)(parent);
     6f8:	4c 8b 6c 24 78       	mov    0x78(%rsp),%r13
     6fd:	45 31 f6             	xor    %r14d,%r14d
     700:	c7 84 24 88 00 00 00 	movl   $0x0,0x88(%rsp)
     707:	00 00 00 00 
  else if (parent)
    type = MXML_TEXT;
  else
    type = MXML_IGNORE;

  while ((ch = (*getc_cb)(p, &encoding)) != EOF)
     70b:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
      {
        if (ch == '&')
	  if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
	    goto error;

	if (mxml_add_char(ch, &ptr, &name, &namesize))
     710:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
     715:	48 8d 84 24 b0 00 00 	lea    0xb0(%rsp),%rax
     71c:	00 
     71d:	48 8d 94 24 a0 00 00 	lea    0xa0(%rsp),%rdx
     724:	00 
     725:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
     72a:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
     72f:	e9 db 0f 00 00       	jmpq   170f <mxml_load_data+0x10dc>
  whitespace = 0;
  encoding   = ENCODE_UTF8;

  if (cb && parent)
    type = (*cb)(parent);
  else if (parent)
     734:	84 c0                	test   %al,%al
     736:	c7 84 24 8c 00 00 00 	movl   $0x4,0x8c(%rsp)
     73d:	04 00 00 00 
     741:	75 a5                	jne    6e8 <mxml_load_data+0xb5>
     743:	c7 84 24 8c 00 00 00 	movl   $0xffffffff,0x8c(%rsp)
     74a:	ff ff ff ff 
     74e:	eb 98                	jmp    6e8 <mxml_load_data+0xb5>
  else
    type = MXML_IGNORE;

  while ((ch = (*getc_cb)(p, &encoding)) != EOF)
  {
    if ((ch == '<' ||
     750:	83 fd 3c             	cmp    $0x3c,%ebp
     753:	74 34                	je     789 <mxml_load_data+0x156>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
     755:	83 fd 20             	cmp    $0x20,%ebp
     758:	74 13                	je     76d <mxml_load_data+0x13a>
     75a:	83 fd 09             	cmp    $0x9,%ebp
     75d:	74 0e                	je     76d <mxml_load_data+0x13a>
     75f:	83 fd 0d             	cmp    $0xd,%ebp
     762:	74 09                	je     76d <mxml_load_data+0x13a>
     764:	83 fd 0a             	cmp    $0xa,%ebp
     767:	0f 85 47 02 00 00    	jne    9b4 <mxml_load_data+0x381>
  else
    type = MXML_IGNORE;

  while ((ch = (*getc_cb)(p, &encoding)) != EOF)
  {
    if ((ch == '<' ||
     76d:	83 bc 24 8c 00 00 00 	cmpl   $0x2,0x8c(%rsp)
     774:	02 
     775:	0f 84 39 02 00 00    	je     9b4 <mxml_load_data+0x381>
     77b:	83 bc 24 8c 00 00 00 	cmpl   $0x5,0x8c(%rsp)
     782:	05 
     783:	0f 84 2b 02 00 00    	je     9b4 <mxml_load_data+0x381>
     789:	48 8b 84 24 b8 00 00 	mov    0xb8(%rsp),%rax
     790:	00 
     791:	48 3b 84 24 c0 00 00 	cmp    0xc0(%rsp),%rax
     798:	00 
     799:	0f 86 15 02 00 00    	jbe    9b4 <mxml_load_data+0x381>
    {
     /*
      * Add a new value node...
      */

      *bufptr = '\0';
     79f:	c6 00 00             	movb   $0x0,(%rax)

      switch (type)
     7a2:	8b 84 24 8c 00 00 00 	mov    0x8c(%rsp),%eax
     7a9:	ff c8                	dec    %eax
     7ab:	83 f8 04             	cmp    $0x4,%eax
     7ae:	0f 87 ee 00 00 00    	ja     8a2 <mxml_load_data+0x26f>
     7b4:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 7bb <mxml_load_data+0x188>
     7bb:	89 c0                	mov    %eax,%eax
     7bd:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
     7c1:	48 01 d0             	add    %rdx,%rax
     7c4:	ff e0                	jmpq   *%rax
      {
	case MXML_INTEGER :
            node = mxmlNewInteger(parent, strtol(buffer, &bufptr, 0));
     7c6:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
     7cd:	00 
     7ce:	48 8d b4 24 b8 00 00 	lea    0xb8(%rsp),%rsi
     7d5:	00 
     7d6:	31 d2                	xor    %edx,%edx
     7d8:	e8 00 00 00 00       	callq  7dd <mxml_load_data+0x1aa>
     7dd:	4c 89 ef             	mov    %r13,%rdi
     7e0:	89 c6                	mov    %eax,%esi
     7e2:	e8 00 00 00 00       	callq  7e7 <mxml_load_data+0x1b4>
     7e7:	eb 48                	jmp    831 <mxml_load_data+0x1fe>
	    break;

	case MXML_OPAQUE :
            node = mxmlNewOpaque(parent, buffer);
     7e9:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     7f0:	00 
     7f1:	4c 89 ef             	mov    %r13,%rdi
     7f4:	e8 00 00 00 00       	callq  7f9 <mxml_load_data+0x1c6>
     7f9:	eb 36                	jmp    831 <mxml_load_data+0x1fe>
	    break;

	case MXML_REAL :
            node = mxmlNewReal(parent, strtod(buffer, &bufptr));
     7fb:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
     802:	00 
     803:	48 8d b4 24 b8 00 00 	lea    0xb8(%rsp),%rsi
     80a:	00 
     80b:	e8 00 00 00 00       	callq  810 <mxml_load_data+0x1dd>
     810:	4c 89 ef             	mov    %r13,%rdi
     813:	e8 00 00 00 00       	callq  818 <mxml_load_data+0x1e5>
     818:	eb 17                	jmp    831 <mxml_load_data+0x1fe>
	    break;

	case MXML_TEXT :
            node = mxmlNewText(parent, whitespace, buffer);
     81a:	48 8b 94 24 c0 00 00 	mov    0xc0(%rsp),%rdx
     821:	00 
     822:	8b b4 24 88 00 00 00 	mov    0x88(%rsp),%esi
     829:	4c 89 ef             	mov    %r13,%rdi
     82c:	e8 00 00 00 00       	callq  831 <mxml_load_data+0x1fe>
     831:	48 89 c3             	mov    %rax,%rbx
     834:	eb 6e                	jmp    8a4 <mxml_load_data+0x271>
	    break;

	case MXML_CUSTOM :
	    if (global->custom_load_cb)
     836:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
     83d:	00 
     83e:	48 83 b8 38 03 00 00 	cmpq   $0x0,0x338(%rax)
     845:	00 
     846:	74 5a                	je     8a2 <mxml_load_data+0x26f>
	    {
	     /*
	      * Use the callback to fill in the custom data...
	      */

              node = mxmlNewCustom(parent, NULL, NULL);
     848:	31 d2                	xor    %edx,%edx
     84a:	31 f6                	xor    %esi,%esi
     84c:	4c 89 ef             	mov    %r13,%rdi
     84f:	e8 00 00 00 00       	callq  854 <mxml_load_data+0x221>

	      if ((*global->custom_load_cb)(node, buffer))
     854:	48 8b 94 24 90 00 00 	mov    0x90(%rsp),%rdx
     85b:	00 
	    {
	     /*
	      * Use the callback to fill in the custom data...
	      */

              node = mxmlNewCustom(parent, NULL, NULL);
     85c:	48 89 c3             	mov    %rax,%rbx

	      if ((*global->custom_load_cb)(node, buffer))
     85f:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     866:	00 
     867:	48 89 c7             	mov    %rax,%rdi
     86a:	ff 92 38 03 00 00    	callq  *0x338(%rdx)
     870:	85 c0                	test   %eax,%eax
     872:	74 30                	je     8a4 <mxml_load_data+0x271>
	      {
	        mxml_error("Bad custom value '%s' in parent <%s>!",
     874:	4d 85 ed             	test   %r13,%r13
     877:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 87e <mxml_load_data+0x24b>
     87e:	74 04                	je     884 <mxml_load_data+0x251>
     880:	49 8b 55 30          	mov    0x30(%r13),%rdx
     884:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     88b:	00 
     88c:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 893 <mxml_load_data+0x260>
     893:	31 c0                	xor    %eax,%eax
     895:	e8 00 00 00 00       	callq  89a <mxml_load_data+0x267>
		           buffer, parent ? parent->value.element.name : "null");
		mxmlDelete(node);
     89a:	48 89 df             	mov    %rbx,%rdi
     89d:	e8 00 00 00 00       	callq  8a2 <mxml_load_data+0x26f>
     8a2:	31 db                	xor    %ebx,%ebx
        default : /* Ignore... */
	    node = NULL;
	    break;
      }

      if (*bufptr)
     8a4:	48 8b 84 24 b8 00 00 	mov    0xb8(%rsp),%rax
     8ab:	00 
     8ac:	80 38 00             	cmpb   $0x0,(%rax)
     8af:	74 45                	je     8f6 <mxml_load_data+0x2c3>
      {
       /*
        * Bad integer/real number value...
	*/

        mxml_error("Bad %s value '%s' in parent <%s>!",
     8b1:	4d 85 ed             	test   %r13,%r13
     8b4:	48 8d 0d 00 00 00 00 	lea    0x0(%rip),%rcx        # 8bb <mxml_load_data+0x288>
     8bb:	74 04                	je     8c1 <mxml_load_data+0x28e>
     8bd:	49 8b 4d 30          	mov    0x30(%r13),%rcx
     8c1:	83 bc 24 8c 00 00 00 	cmpl   $0x1,0x8c(%rsp)
     8c8:	01 
     8c9:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 8d0 <mxml_load_data+0x29d>
     8d0:	48 8b 94 24 c0 00 00 	mov    0xc0(%rsp),%rdx
     8d7:	00 
     8d8:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # 8df <mxml_load_data+0x2ac>
     8df:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 8e6 <mxml_load_data+0x2b3>
     8e6:	48 0f 44 f0          	cmove  %rax,%rsi
     8ea:	31 c0                	xor    %eax,%eax
     8ec:	e8 00 00 00 00       	callq  8f1 <mxml_load_data+0x2be>
     8f1:	e9 31 0e 00 00       	jmpq   1727 <mxml_load_data+0x10f4>
	           type == MXML_INTEGER ? "integer" : "real", buffer,
		   parent ? parent->value.element.name : "null");
	break;
      }

      bufptr     = buffer;
     8f6:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
     8fd:	00 
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
     8fe:	83 fd 20             	cmp    $0x20,%ebp
	           type == MXML_INTEGER ? "integer" : "real", buffer,
		   parent ? parent->value.element.name : "null");
	break;
      }

      bufptr     = buffer;
     901:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
     908:	00 
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
     909:	74 1a                	je     925 <mxml_load_data+0x2f2>
     90b:	83 fd 09             	cmp    $0x9,%ebp
     90e:	74 15                	je     925 <mxml_load_data+0x2f2>
     910:	83 fd 0d             	cmp    $0xd,%ebp
     913:	74 10                	je     925 <mxml_load_data+0x2f2>
     915:	83 fd 0a             	cmp    $0xa,%ebp
     918:	c7 84 24 88 00 00 00 	movl   $0x0,0x88(%rsp)
     91f:	00 00 00 00 
     923:	75 14                	jne    939 <mxml_load_data+0x306>
     925:	31 c0                	xor    %eax,%eax
     927:	83 bc 24 8c 00 00 00 	cmpl   $0x4,0x8c(%rsp)
     92e:	04 
     92f:	0f 94 c0             	sete   %al
     932:	89 84 24 88 00 00 00 	mov    %eax,0x88(%rsp)
      }

      bufptr     = buffer;
      whitespace = mxml_isspace(ch) && type == MXML_TEXT;

      if (!node && type != MXML_IGNORE)
     939:	48 85 db             	test   %rbx,%rbx
     93c:	75 3c                	jne    97a <mxml_load_data+0x347>
     93e:	83 bc 24 8c 00 00 00 	cmpl   $0xffffffffffffffff,0x8c(%rsp)
     945:	ff 
     946:	74 32                	je     97a <mxml_load_data+0x347>
      {
       /*
	* Print error and return...
	*/

	mxml_error("Unable to add value node of type %s to parent <%s>!",
     948:	4d 85 ed             	test   %r13,%r13
     94b:	48 8d 0d 00 00 00 00 	lea    0x0(%rip),%rcx        # 952 <mxml_load_data+0x31f>
     952:	74 04                	je     958 <mxml_load_data+0x325>
     954:	49 8b 4d 30          	mov    0x30(%r13),%rcx
     958:	48 63 84 24 8c 00 00 	movslq 0x8c(%rsp),%rax
     95f:	00 
     960:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 967 <mxml_load_data+0x334>
     967:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 96e <mxml_load_data+0x33b>
     96e:	48 8b 34 c2          	mov    (%rdx,%rax,8),%rsi
     972:	48 89 ca             	mov    %rcx,%rdx
     975:	e9 10 03 00 00       	jmpq   c8a <mxml_load_data+0x657>
	           types[type], parent ? parent->value.element.name : "null");
	goto error;
      }

      if (sax_cb)
     97a:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
     980:	74 24                	je     9a6 <mxml_load_data+0x373>
      {
        (*sax_cb)(node, MXML_SAX_DATA, sax_data);
     982:	48 89 df             	mov    %rbx,%rdi
     985:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
     98a:	be 02 00 00 00       	mov    $0x2,%esi
     98f:	ff 54 24 60          	callq  *0x60(%rsp)

        if (!mxmlRelease(node))
     993:	48 89 df             	mov    %rbx,%rdi
     996:	e8 00 00 00 00       	callq  99b <mxml_load_data+0x368>
     99b:	85 c0                	test   %eax,%eax
     99d:	b8 00 00 00 00       	mov    $0x0,%eax
     9a2:	48 0f 44 d8          	cmove  %rax,%rbx
          node = NULL;
      }

      if (!first && node)
     9a6:	4d 85 f6             	test   %r14,%r14
     9a9:	75 39                	jne    9e4 <mxml_load_data+0x3b1>
     9ab:	48 85 db             	test   %rbx,%rbx
     9ae:	4c 0f 45 f3          	cmovne %rbx,%r14
     9b2:	eb 30                	jmp    9e4 <mxml_load_data+0x3b1>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
     9b4:	83 fd 20             	cmp    $0x20,%ebp
     9b7:	74 0f                	je     9c8 <mxml_load_data+0x395>
     9b9:	83 fd 09             	cmp    $0x9,%ebp
     9bc:	74 0a                	je     9c8 <mxml_load_data+0x395>
     9be:	83 fd 0d             	cmp    $0xd,%ebp
     9c1:	74 05                	je     9c8 <mxml_load_data+0x395>
     9c3:	83 fd 0a             	cmp    $0xa,%ebp
     9c6:	75 1c                	jne    9e4 <mxml_load_data+0x3b1>
      }

      if (!first && node)
        first = node;
    }
    else if (mxml_isspace(ch) && type == MXML_TEXT)
     9c8:	83 bc 24 8c 00 00 00 	cmpl   $0x4,0x8c(%rsp)
     9cf:	04 
     9d0:	b8 01 00 00 00       	mov    $0x1,%eax
     9d5:	0f 45 84 24 88 00 00 	cmovne 0x88(%rsp),%eax
     9dc:	00 
     9dd:	89 84 24 88 00 00 00 	mov    %eax,0x88(%rsp)
   /*
    * Add lone whitespace node if we have an element and existing
    * whitespace...
    */

    if (ch == '<' && whitespace && type == MXML_TEXT)
     9e4:	83 fd 3c             	cmp    $0x3c,%ebp
     9e7:	0f 85 94 0c 00 00    	jne    1681 <mxml_load_data+0x104e>
     9ed:	83 bc 24 88 00 00 00 	cmpl   $0x0,0x88(%rsp)
     9f4:	00 
     9f5:	74 78                	je     a6f <mxml_load_data+0x43c>
     9f7:	83 bc 24 8c 00 00 00 	cmpl   $0x4,0x8c(%rsp)
     9fe:	04 
     9ff:	c7 84 24 88 00 00 00 	movl   $0x1,0x88(%rsp)
     a06:	01 00 00 00 
     a0a:	75 63                	jne    a6f <mxml_load_data+0x43c>
    {
      if (parent)
     a0c:	4d 85 ed             	test   %r13,%r13
     a0f:	0f 84 aa 0d 00 00    	je     17bf <mxml_load_data+0x118c>
      {
	node = mxmlNewText(parent, whitespace, "");
     a15:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # a1c <mxml_load_data+0x3e9>
     a1c:	be 01 00 00 00       	mov    $0x1,%esi
     a21:	4c 89 ef             	mov    %r13,%rdi
     a24:	e8 00 00 00 00       	callq  a29 <mxml_load_data+0x3f6>

	if (sax_cb)
     a29:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)

    if (ch == '<' && whitespace && type == MXML_TEXT)
    {
      if (parent)
      {
	node = mxmlNewText(parent, whitespace, "");
     a2f:	48 89 c3             	mov    %rax,%rbx

	if (sax_cb)
     a32:	74 24                	je     a58 <mxml_load_data+0x425>
	{
	  (*sax_cb)(node, MXML_SAX_DATA, sax_data);
     a34:	48 89 c7             	mov    %rax,%rdi
     a37:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
     a3c:	be 02 00 00 00       	mov    $0x2,%esi
     a41:	ff 54 24 60          	callq  *0x60(%rsp)

	  if (!mxmlRelease(node))
     a45:	48 89 df             	mov    %rbx,%rdi
     a48:	e8 00 00 00 00       	callq  a4d <mxml_load_data+0x41a>
     a4d:	85 c0                	test   %eax,%eax
     a4f:	b8 00 00 00 00       	mov    $0x0,%eax
     a54:	48 0f 44 d8          	cmove  %rax,%rbx
	    node = NULL;
	}

	if (!first && node)
     a58:	4d 85 f6             	test   %r14,%r14
     a5b:	0f 85 5e 0d 00 00    	jne    17bf <mxml_load_data+0x118c>
     a61:	48 85 db             	test   %rbx,%rbx
     a64:	0f 85 52 0d 00 00    	jne    17bc <mxml_load_data+0x1189>
     a6a:	e9 50 0d 00 00       	jmpq   17bf <mxml_load_data+0x118c>
    {
     /*
      * Start of open/close tag...
      */

      bufptr = buffer;
     a6f:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
     a76:	00 
	    goto error;

	  if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
	    goto error;
	}
	else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     a77:	4c 8d a4 24 c0 00 00 	lea    0xc0(%rsp),%r12
     a7e:	00 
     a7f:	48 8d 9c 24 b8 00 00 	lea    0xb8(%rsp),%rbx
     a86:	00 
    {
     /*
      * Start of open/close tag...
      */

      bufptr = buffer;
     a87:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
     a8e:	00 
	    goto error;

	  if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
	    goto error;
	}
	else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     a8f:	48 8d 84 24 d4 00 00 	lea    0xd4(%rsp),%rax
     a96:	00 
     a97:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
     a9c:	e9 00 01 00 00       	jmpq   ba1 <mxml_load_data+0x56e>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
     aa1:	83 fd 20             	cmp    $0x20,%ebp
     aa4:	0f 84 0f 01 00 00    	je     bb9 <mxml_load_data+0x586>
     aaa:	83 fd 09             	cmp    $0x9,%ebp
     aad:	0f 84 06 01 00 00    	je     bb9 <mxml_load_data+0x586>
     ab3:	83 fd 0d             	cmp    $0xd,%ebp
     ab6:	0f 84 fd 00 00 00    	je     bb9 <mxml_load_data+0x586>
     abc:	83 fd 0a             	cmp    $0xa,%ebp
     abf:	0f 85 0a 0d 00 00    	jne    17cf <mxml_load_data+0x119c>
     ac5:	e9 ef 00 00 00       	jmpq   bb9 <mxml_load_data+0x586>
      */

      bufptr = buffer;

      while ((ch = (*getc_cb)(p, &encoding)) != EOF)
        if (mxml_isspace(ch) || ch == '>' || (ch == '/' && bufptr > buffer))
     aca:	83 fd 2f             	cmp    $0x2f,%ebp
     acd:	75 17                	jne    ae6 <mxml_load_data+0x4b3>
     acf:	48 8b 94 24 c0 00 00 	mov    0xc0(%rsp),%rdx
     ad6:	00 
     ad7:	48 39 94 24 b8 00 00 	cmp    %rdx,0xb8(%rsp)
     ade:	00 
     adf:	76 54                	jbe    b35 <mxml_load_data+0x502>
     ae1:	e9 d3 00 00 00       	jmpq   bb9 <mxml_load_data+0x586>
	  break;
	else if (ch == '<')
     ae6:	83 fd 3c             	cmp    $0x3c,%ebp
     ae9:	75 0c                	jne    af7 <mxml_load_data+0x4c4>
	{
	  mxml_error("Bare < in element!");
     aeb:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # af2 <mxml_load_data+0x4bf>
     af2:	e9 67 01 00 00       	jmpq   c5e <mxml_load_data+0x62b>
	  goto error;
	}
	else if (ch == '&')
     af7:	83 fd 26             	cmp    $0x26,%ebp
     afa:	75 39                	jne    b35 <mxml_load_data+0x502>
	{
	  if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb)) == EOF)
     afc:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
     b01:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
     b06:	4c 89 ef             	mov    %r13,%rdi
     b09:	4c 89 f9             	mov    %r15,%rcx
     b0c:	e8 8a f8 ff ff       	callq  39b <mxml_get_entity>
     b11:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     b14:	89 c7                	mov    %eax,%edi
     b16:	0f 84 73 0c 00 00    	je     178f <mxml_load_data+0x115c>
	    goto error;

	  if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     b1c:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     b21:	4c 89 e2             	mov    %r12,%rdx
     b24:	48 89 de             	mov    %rbx,%rsi
     b27:	e8 d2 f9 ff ff       	callq  4fe <mxml_add_char>
     b2c:	85 c0                	test   %eax,%eax
     b2e:	74 71                	je     ba1 <mxml_load_data+0x56e>
     b30:	e9 5a 0c 00 00       	jmpq   178f <mxml_load_data+0x115c>
	    goto error;
	}
	else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     b35:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     b3a:	4c 89 e2             	mov    %r12,%rdx
     b3d:	48 89 de             	mov    %rbx,%rsi
     b40:	89 ef                	mov    %ebp,%edi
     b42:	e8 b7 f9 ff ff       	callq  4fe <mxml_add_char>
     b47:	85 c0                	test   %eax,%eax
     b49:	0f 85 40 0c 00 00    	jne    178f <mxml_load_data+0x115c>
	  goto error;
	else if (((bufptr - buffer) == 1 && buffer[0] == '?') ||
     b4f:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
     b56:	00 
     b57:	48 8b 84 24 b8 00 00 	mov    0xb8(%rsp),%rax
     b5e:	00 
     b5f:	48 29 f8             	sub    %rdi,%rax
     b62:	48 83 f8 01          	cmp    $0x1,%rax
     b66:	75 05                	jne    b6d <mxml_load_data+0x53a>
     b68:	80 3f 3f             	cmpb   $0x3f,(%rdi)
     b6b:	eb 32                	jmp    b9f <mxml_load_data+0x56c>
     b6d:	48 83 f8 03          	cmp    $0x3,%rax
     b71:	75 13                	jne    b86 <mxml_load_data+0x553>
     b73:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # b7a <mxml_load_data+0x547>
     b7a:	ba 03 00 00 00       	mov    $0x3,%edx
     b7f:	e8 00 00 00 00       	callq  b84 <mxml_load_data+0x551>
     b84:	eb 17                	jmp    b9d <mxml_load_data+0x56a>
     b86:	48 83 f8 08          	cmp    $0x8,%rax
     b8a:	75 15                	jne    ba1 <mxml_load_data+0x56e>
     b8c:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # b93 <mxml_load_data+0x560>
     b93:	ba 08 00 00 00       	mov    $0x8,%edx
     b98:	e8 00 00 00 00       	callq  b9d <mxml_load_data+0x56a>
     b9d:	85 c0                	test   %eax,%eax
     b9f:	74 18                	je     bb9 <mxml_load_data+0x586>
      * Start of open/close tag...
      */

      bufptr = buffer;

      while ((ch = (*getc_cb)(p, &encoding)) != EOF)
     ba1:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
     ba6:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
     bab:	41 ff d7             	callq  *%r15
     bae:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     bb1:	89 c5                	mov    %eax,%ebp
     bb3:	0f 85 e8 fe ff ff    	jne    aa1 <mxml_load_data+0x46e>
	else if (((bufptr - buffer) == 1 && buffer[0] == '?') ||
	         ((bufptr - buffer) == 3 && !strncmp(buffer, "!--", 3)) ||
	         ((bufptr - buffer) == 8 && !strncmp(buffer, "![CDATA[", 8)))
	  break;

      *bufptr = '\0';
     bb9:	48 8b 84 24 b8 00 00 	mov    0xb8(%rsp),%rax
     bc0:	00 

      if (!strcmp(buffer, "!--"))
     bc1:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # bc8 <mxml_load_data+0x595>
	else if (((bufptr - buffer) == 1 && buffer[0] == '?') ||
	         ((bufptr - buffer) == 3 && !strncmp(buffer, "!--", 3)) ||
	         ((bufptr - buffer) == 8 && !strncmp(buffer, "![CDATA[", 8)))
	  break;

      *bufptr = '\0';
     bc8:	c6 00 00             	movb   $0x0,(%rax)

      if (!strcmp(buffer, "!--"))
     bcb:	48 8b 9c 24 c0 00 00 	mov    0xc0(%rsp),%rbx
     bd2:	00 
     bd3:	48 89 df             	mov    %rbx,%rdi
     bd6:	e8 00 00 00 00       	callq  bdb <mxml_load_data+0x5a8>
     bdb:	85 c0                	test   %eax,%eax
     bdd:	74 4c                	je     c2b <mxml_load_data+0x5f8>
     bdf:	e9 08 01 00 00       	jmpq   cec <mxml_load_data+0x6b9>
        * Gather rest of comment...
	*/

	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
	{
	  if (ch == '>' && bufptr > (buffer + 4) &&
     be4:	83 ff 3e             	cmp    $0x3e,%edi
     be7:	75 2b                	jne    c14 <mxml_load_data+0x5e1>
     be9:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
     bf0:	00 
     bf1:	48 8b 94 24 b8 00 00 	mov    0xb8(%rsp),%rdx
     bf8:	00 
     bf9:	48 83 c0 04          	add    $0x4,%rax
     bfd:	48 39 c2             	cmp    %rax,%rdx
     c00:	76 12                	jbe    c14 <mxml_load_data+0x5e1>
     c02:	80 7a fd 2d          	cmpb   $0x2d,-0x3(%rdx)
     c06:	74 0c                	je     c14 <mxml_load_data+0x5e1>
     c08:	80 7a fe 2d          	cmpb   $0x2d,-0x2(%rdx)
     c0c:	75 06                	jne    c14 <mxml_load_data+0x5e1>
     c0e:	80 7a ff 2d          	cmpb   $0x2d,-0x1(%rdx)
     c12:	74 56                	je     c6a <mxml_load_data+0x637>
	      bufptr[-3] != '-' && bufptr[-2] == '-' && bufptr[-1] == '-')
	    break;
	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     c14:	4c 89 e1             	mov    %r12,%rcx
     c17:	48 89 ea             	mov    %rbp,%rdx
     c1a:	48 89 de             	mov    %rbx,%rsi
     c1d:	e8 dc f8 ff ff       	callq  4fe <mxml_add_char>
     c22:	85 c0                	test   %eax,%eax
     c24:	74 1d                	je     c43 <mxml_load_data+0x610>
     c26:	e9 64 0b 00 00       	jmpq   178f <mxml_load_data+0x115c>
     c2b:	4c 8d a4 24 d4 00 00 	lea    0xd4(%rsp),%r12
     c32:	00 
     c33:	48 8d ac 24 c0 00 00 	lea    0xc0(%rsp),%rbp
     c3a:	00 
     c3b:	48 8d 9c 24 b8 00 00 	lea    0xb8(%rsp),%rbx
     c42:	00 
      {
       /*
        * Gather rest of comment...
	*/

	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
     c43:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
     c48:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
     c4d:	41 ff d7             	callq  *%r15
     c50:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     c53:	89 c7                	mov    %eax,%edi
     c55:	75 8d                	jne    be4 <mxml_load_data+0x5b1>
	{
	 /*
	  * Print error and return...
	  */

	  mxml_error("Early EOF in comment node!");
     c57:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # c5e <mxml_load_data+0x62b>
     c5e:	31 c0                	xor    %eax,%eax
     c60:	e8 00 00 00 00       	callq  c65 <mxml_load_data+0x632>
     c65:	e9 25 0b 00 00       	jmpq   178f <mxml_load_data+0x115c>
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';

        if (!parent && first)
     c6a:	4d 85 ed             	test   %r13,%r13

       /*
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';
     c6d:	c6 02 00             	movb   $0x0,(%rdx)

        if (!parent && first)
     c70:	75 24                	jne    c96 <mxml_load_data+0x663>
     c72:	4d 85 f6             	test   %r14,%r14
     c75:	74 1f                	je     c96 <mxml_load_data+0x663>
	{
	 /*
	  * There can only be one root element!
	  */

	  mxml_error("<%s> cannot be a second root node after <%s>",
     c77:	49 8b 56 30          	mov    0x30(%r14),%rdx
     c7b:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     c82:	00 
     c83:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # c8a <mxml_load_data+0x657>
     c8a:	31 c0                	xor    %eax,%eax
     c8c:	e8 00 00 00 00       	callq  c91 <mxml_load_data+0x65e>
     c91:	e9 f9 0a 00 00       	jmpq   178f <mxml_load_data+0x115c>
	             buffer, first->value.element.name);
          goto error;
	}

	if ((node = mxmlNewElement(parent, buffer)) == NULL)
     c96:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     c9d:	00 
     c9e:	4c 89 ef             	mov    %r13,%rdi
     ca1:	e8 00 00 00 00       	callq  ca6 <mxml_load_data+0x673>
     ca6:	48 85 c0             	test   %rax,%rax
     ca9:	48 89 c3             	mov    %rax,%rbx
     cac:	75 23                	jne    cd1 <mxml_load_data+0x69e>
	{
	 /*
	  * Just print error for now...
	  */

	  mxml_error("Unable to add comment node to parent <%s>!",
     cae:	4d 85 ed             	test   %r13,%r13
     cb1:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # cb8 <mxml_load_data+0x685>
     cb8:	74 04                	je     cbe <mxml_load_data+0x68b>
     cba:	49 8b 75 30          	mov    0x30(%r13),%rsi
     cbe:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # cc5 <mxml_load_data+0x692>
     cc5:	31 c0                	xor    %eax,%eax
     cc7:	e8 00 00 00 00       	callq  ccc <mxml_load_data+0x699>
     ccc:	e9 56 0a 00 00       	jmpq   1727 <mxml_load_data+0x10f4>
	             parent ? parent->value.element.name : "null");
	  break;
	}

        if (sax_cb)
     cd1:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
     cd7:	0f 84 18 01 00 00    	je     df5 <mxml_load_data+0x7c2>
        {
          (*sax_cb)(node, MXML_SAX_COMMENT, sax_data);
     cdd:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
     ce2:	be 01 00 00 00       	mov    $0x1,%esi
     ce7:	e9 f2 00 00 00       	jmpq   dde <mxml_load_data+0x7ab>
        }

	if (node && !first)
	  first = node;
      }
      else if (!strcmp(buffer, "![CDATA["))
     cec:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # cf3 <mxml_load_data+0x6c0>
     cf3:	48 89 df             	mov    %rbx,%rdi
     cf6:	e8 00 00 00 00       	callq  cfb <mxml_load_data+0x6c8>
     cfb:	85 c0                	test   %eax,%eax
     cfd:	74 48                	je     d47 <mxml_load_data+0x714>
     cff:	e9 0b 01 00 00       	jmpq   e0f <mxml_load_data+0x7dc>
        * Gather CDATA section...
	*/

	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
	{
	  if (ch == '>' && !strncmp(bufptr - 2, "]]", 2))
     d04:	83 fb 3e             	cmp    $0x3e,%ebx
     d07:	75 21                	jne    d2a <mxml_load_data+0x6f7>
     d09:	48 8b ac 24 b8 00 00 	mov    0xb8(%rsp),%rbp
     d10:	00 
     d11:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # d18 <mxml_load_data+0x6e5>
     d18:	ba 02 00 00 00       	mov    $0x2,%edx
     d1d:	48 8d 7d fe          	lea    -0x2(%rbp),%rdi
     d21:	e8 00 00 00 00       	callq  d26 <mxml_load_data+0x6f3>
     d26:	85 c0                	test   %eax,%eax
     d28:	74 5f                	je     d89 <mxml_load_data+0x756>
	    break;
	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     d2a:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
     d2f:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
     d34:	4c 89 e6             	mov    %r12,%rsi
     d37:	89 df                	mov    %ebx,%edi
     d39:	e8 c0 f7 ff ff       	callq  4fe <mxml_add_char>
     d3e:	85 c0                	test   %eax,%eax
     d40:	74 27                	je     d69 <mxml_load_data+0x736>
     d42:	e9 48 0a 00 00       	jmpq   178f <mxml_load_data+0x115c>
     d47:	48 8d 84 24 d4 00 00 	lea    0xd4(%rsp),%rax
     d4e:	00 
     d4f:	48 8d 94 24 c0 00 00 	lea    0xc0(%rsp),%rdx
     d56:	00 
     d57:	4c 8d a4 24 b8 00 00 	lea    0xb8(%rsp),%r12
     d5e:	00 
     d5f:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
     d64:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
      {
       /*
        * Gather CDATA section...
	*/

	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
     d69:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
     d6e:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
     d73:	41 ff d7             	callq  *%r15
     d76:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     d79:	89 c3                	mov    %eax,%ebx
     d7b:	75 87                	jne    d04 <mxml_load_data+0x6d1>
	{
	 /*
	  * Print error and return...
	  */

	  mxml_error("Early EOF in CDATA node!");
     d7d:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # d84 <mxml_load_data+0x751>
     d84:	e9 d5 fe ff ff       	jmpq   c5e <mxml_load_data+0x62b>
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';

        if (!parent && first)
     d89:	4d 85 ed             	test   %r13,%r13

       /*
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';
     d8c:	c6 45 00 00          	movb   $0x0,0x0(%rbp)

        if (!parent && first)
     d90:	75 09                	jne    d9b <mxml_load_data+0x768>
     d92:	4d 85 f6             	test   %r14,%r14
     d95:	0f 85 dc fe ff ff    	jne    c77 <mxml_load_data+0x644>
	  mxml_error("<%s> cannot be a second root node after <%s>",
	             buffer, first->value.element.name);
          goto error;
	}

	if ((node = mxmlNewElement(parent, buffer)) == NULL)
     d9b:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     da2:	00 
     da3:	4c 89 ef             	mov    %r13,%rdi
     da6:	e8 00 00 00 00       	callq  dab <mxml_load_data+0x778>
     dab:	48 85 c0             	test   %rax,%rax
     dae:	48 89 c3             	mov    %rax,%rbx
     db1:	75 1c                	jne    dcf <mxml_load_data+0x79c>
	{
	 /*
	  * Print error and return...
	  */

	  mxml_error("Unable to add CDATA node to parent <%s>!",
     db3:	4d 85 ed             	test   %r13,%r13
     db6:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # dbd <mxml_load_data+0x78a>
     dbd:	74 04                	je     dc3 <mxml_load_data+0x790>
     dbf:	49 8b 75 30          	mov    0x30(%r13),%rsi
     dc3:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # dca <mxml_load_data+0x797>
     dca:	e9 32 03 00 00       	jmpq   1101 <mxml_load_data+0xace>
	             parent ? parent->value.element.name : "null");
	  goto error;
	}

        if (sax_cb)
     dcf:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
     dd5:	74 1e                	je     df5 <mxml_load_data+0x7c2>
        {
          (*sax_cb)(node, MXML_SAX_CDATA, sax_data);
     dd7:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
     ddc:	31 f6                	xor    %esi,%esi
     dde:	48 89 df             	mov    %rbx,%rdi
     de1:	ff 54 24 60          	callq  *0x60(%rsp)

          if (!mxmlRelease(node))
     de5:	48 89 df             	mov    %rbx,%rdi
     de8:	e8 00 00 00 00       	callq  ded <mxml_load_data+0x7ba>
     ded:	85 c0                	test   %eax,%eax
     def:	0f 84 71 08 00 00    	je     1666 <mxml_load_data+0x1033>
            node = NULL;
        }

	if (node && !first)
     df5:	48 85 db             	test   %rbx,%rbx
     df8:	0f 84 68 08 00 00    	je     1666 <mxml_load_data+0x1033>
     dfe:	4d 85 f6             	test   %r14,%r14
     e01:	0f 85 5f 08 00 00    	jne    1666 <mxml_load_data+0x1033>
     e07:	49 89 de             	mov    %rbx,%r14
     e0a:	e9 57 08 00 00       	jmpq   1666 <mxml_load_data+0x1033>
	  first = node;
      }
      else if (buffer[0] == '?')
     e0f:	8a 03                	mov    (%rbx),%al
     e11:	3c 3f                	cmp    $0x3f,%al
     e13:	0f 85 bb 00 00 00    	jne    ed4 <mxml_load_data+0x8a1>
     e19:	eb 34                	jmp    e4f <mxml_load_data+0x81c>
        * Gather rest of processing instruction...
	*/

	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
	{
	  if (ch == '>' && bufptr > buffer && bufptr[-1] == '?')
     e1b:	83 ff 3e             	cmp    $0x3e,%edi
     e1e:	75 18                	jne    e38 <mxml_load_data+0x805>
     e20:	48 8b 84 24 b8 00 00 	mov    0xb8(%rsp),%rax
     e27:	00 
     e28:	48 3b 84 24 c0 00 00 	cmp    0xc0(%rsp),%rax
     e2f:	00 
     e30:	76 06                	jbe    e38 <mxml_load_data+0x805>
     e32:	80 78 ff 3f          	cmpb   $0x3f,-0x1(%rax)
     e36:	74 4f                	je     e87 <mxml_load_data+0x854>
	    break;
	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     e38:	4c 89 e1             	mov    %r12,%rcx
     e3b:	48 89 ea             	mov    %rbp,%rdx
     e3e:	48 89 de             	mov    %rbx,%rsi
     e41:	e8 b8 f6 ff ff       	callq  4fe <mxml_add_char>
     e46:	85 c0                	test   %eax,%eax
     e48:	74 1d                	je     e67 <mxml_load_data+0x834>
     e4a:	e9 40 09 00 00       	jmpq   178f <mxml_load_data+0x115c>
     e4f:	4c 8d a4 24 d4 00 00 	lea    0xd4(%rsp),%r12
     e56:	00 
     e57:	48 8d ac 24 c0 00 00 	lea    0xc0(%rsp),%rbp
     e5e:	00 
     e5f:	48 8d 9c 24 b8 00 00 	lea    0xb8(%rsp),%rbx
     e66:	00 
      {
       /*
        * Gather rest of processing instruction...
	*/

	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
     e67:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
     e6c:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
     e71:	41 ff d7             	callq  *%r15
     e74:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     e77:	89 c7                	mov    %eax,%edi
     e79:	75 a0                	jne    e1b <mxml_load_data+0x7e8>
	{
	 /*
	  * Print error and return...
	  */

	  mxml_error("Early EOF in processing instruction node!");
     e7b:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # e82 <mxml_load_data+0x84f>
     e82:	e9 d7 fd ff ff       	jmpq   c5e <mxml_load_data+0x62b>
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';

        if (!parent && first)
     e87:	4d 85 ed             	test   %r13,%r13

       /*
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';
     e8a:	c6 00 00             	movb   $0x0,(%rax)

        if (!parent && first)
     e8d:	40 0f 94 c5          	sete   %bpl
     e91:	75 09                	jne    e9c <mxml_load_data+0x869>
     e93:	4d 85 f6             	test   %r14,%r14
     e96:	0f 85 db fd ff ff    	jne    c77 <mxml_load_data+0x644>
	  mxml_error("<%s> cannot be a second root node after <%s>",
	             buffer, first->value.element.name);
          goto error;
	}

	if ((node = mxmlNewElement(parent, buffer)) == NULL)
     e9c:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     ea3:	00 
     ea4:	4c 89 ef             	mov    %r13,%rdi
     ea7:	e8 00 00 00 00       	callq  eac <mxml_load_data+0x879>
     eac:	48 85 c0             	test   %rax,%rax
     eaf:	48 89 c3             	mov    %rax,%rbx
     eb2:	0f 85 f6 00 00 00    	jne    fae <mxml_load_data+0x97b>
	{
	 /*
	  * Print error and return...
	  */

	  mxml_error("Unable to add processing instruction node to parent <%s>!",
     eb8:	4d 85 ed             	test   %r13,%r13
     ebb:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # ec2 <mxml_load_data+0x88f>
     ec2:	74 04                	je     ec8 <mxml_load_data+0x895>
     ec4:	49 8b 75 30          	mov    0x30(%r13),%rsi
     ec8:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # ecf <mxml_load_data+0x89c>
     ecf:	e9 2d 02 00 00       	jmpq   1101 <mxml_load_data+0xace>
	    if (cb)
	      type = (*cb)(parent);
	  }
	}
      }
      else if (buffer[0] == '!')
     ed4:	3c 21                	cmp    $0x21,%al
     ed6:	0f 85 32 01 00 00    	jne    100e <mxml_load_data+0x9db>
	  {
            if (ch == '&')
	      if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb)) == EOF)
		goto error;

	    if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     edc:	48 8d 84 24 d4 00 00 	lea    0xd4(%rsp),%rax
     ee3:	00 
     ee4:	4c 8d a4 24 c0 00 00 	lea    0xc0(%rsp),%r12
     eeb:	00 
     eec:	48 8d 9c 24 b8 00 00 	lea    0xb8(%rsp),%rbx
     ef3:	00 
     ef4:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
        * Gather rest of declaration...
	*/

	do
	{
	  if (ch == '>')
     ef9:	83 fd 3e             	cmp    $0x3e,%ebp
     efc:	74 5f                	je     f5d <mxml_load_data+0x92a>
	    break;
	  else
	  {
            if (ch == '&')
     efe:	83 fd 26             	cmp    $0x26,%ebp
     f01:	75 20                	jne    f23 <mxml_load_data+0x8f0>
	      if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb)) == EOF)
     f03:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
     f08:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
     f0d:	4c 89 f9             	mov    %r15,%rcx
     f10:	4c 89 ef             	mov    %r13,%rdi
     f13:	e8 83 f4 ff ff       	callq  39b <mxml_get_entity>
     f18:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     f1b:	89 c5                	mov    %eax,%ebp
     f1d:	0f 84 6c 08 00 00    	je     178f <mxml_load_data+0x115c>
		goto error;

	    if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
     f23:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
     f28:	4c 89 e2             	mov    %r12,%rdx
     f2b:	48 89 de             	mov    %rbx,%rsi
     f2e:	89 ef                	mov    %ebp,%edi
     f30:	e8 c9 f5 ff ff       	callq  4fe <mxml_add_char>
     f35:	85 c0                	test   %eax,%eax
     f37:	0f 85 52 08 00 00    	jne    178f <mxml_load_data+0x115c>
	      goto error;
	  }
	}
        while ((ch = (*getc_cb)(p, &encoding)) != EOF);
     f3d:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
     f42:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
     f47:	41 ff d7             	callq  *%r15
     f4a:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
     f4d:	89 c5                	mov    %eax,%ebp
     f4f:	75 a8                	jne    ef9 <mxml_load_data+0x8c6>
	{
	 /*
	  * Print error and return...
	  */

	  mxml_error("Early EOF in declaration node!");
     f51:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # f58 <mxml_load_data+0x925>
     f58:	e9 01 fd ff ff       	jmpq   c5e <mxml_load_data+0x62b>

       /*
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';
     f5d:	48 8b 84 24 b8 00 00 	mov    0xb8(%rsp),%rax
     f64:	00 

        if (!parent && first)
     f65:	4d 85 ed             	test   %r13,%r13
     f68:	40 0f 94 c5          	sete   %bpl

       /*
        * Otherwise add this as an element under the current parent...
	*/

	*bufptr = '\0';
     f6c:	c6 00 00             	movb   $0x0,(%rax)

        if (!parent && first)
     f6f:	75 09                	jne    f7a <mxml_load_data+0x947>
     f71:	4d 85 f6             	test   %r14,%r14
     f74:	0f 85 fd fc ff ff    	jne    c77 <mxml_load_data+0x644>
	  mxml_error("<%s> cannot be a second root node after <%s>",
	             buffer, first->value.element.name);
          goto error;
	}

	if ((node = mxmlNewElement(parent, buffer)) == NULL)
     f7a:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
     f81:	00 
     f82:	4c 89 ef             	mov    %r13,%rdi
     f85:	e8 00 00 00 00       	callq  f8a <mxml_load_data+0x957>
     f8a:	48 85 c0             	test   %rax,%rax
     f8d:	48 89 c3             	mov    %rax,%rbx
     f90:	75 1c                	jne    fae <mxml_load_data+0x97b>
	{
	 /*
	  * Print error and return...
	  */

	  mxml_error("Unable to add declaration node to parent <%s>!",
     f92:	4d 85 ed             	test   %r13,%r13
     f95:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # f9c <mxml_load_data+0x969>
     f9c:	74 04                	je     fa2 <mxml_load_data+0x96f>
     f9e:	49 8b 75 30          	mov    0x30(%r13),%rsi
     fa2:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # fa9 <mxml_load_data+0x976>
     fa9:	e9 53 01 00 00       	jmpq   1101 <mxml_load_data+0xace>
	             parent ? parent->value.element.name : "null");
	  goto error;
	}

        if (sax_cb)
     fae:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
     fb4:	74 21                	je     fd7 <mxml_load_data+0x9a4>
        {
          (*sax_cb)(node, MXML_SAX_DIRECTIVE, sax_data);
     fb6:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
     fbb:	be 03 00 00 00       	mov    $0x3,%esi
     fc0:	48 89 df             	mov    %rbx,%rdi
     fc3:	ff 54 24 60          	callq  *0x60(%rsp)

          if (!mxmlRelease(node))
     fc7:	48 89 df             	mov    %rbx,%rdi
     fca:	e8 00 00 00 00       	callq  fcf <mxml_load_data+0x99c>
     fcf:	85 c0                	test   %eax,%eax
     fd1:	0f 84 8f 06 00 00    	je     1666 <mxml_load_data+0x1033>
            node = NULL;
        }

        if (node)
	{
	  if (!first)
     fd7:	4d 85 f6             	test   %r14,%r14
     fda:	4c 0f 44 f3          	cmove  %rbx,%r14
            first = node;

	  if (!parent)
     fde:	40 84 ed             	test   %bpl,%bpl
     fe1:	0f 84 7f 06 00 00    	je     1666 <mxml_load_data+0x1033>
	  {
	    parent = node;

	    if (cb)
     fe7:	80 bc 24 87 00 00 00 	cmpb   $0x0,0x87(%rsp)
     fee:	00 
     fef:	48 89 dd             	mov    %rbx,%rbp
     ff2:	0f 84 71 06 00 00    	je     1669 <mxml_load_data+0x1036>
	      type = (*cb)(parent);
     ff8:	48 89 df             	mov    %rbx,%rdi
     ffb:	48 89 dd             	mov    %rbx,%rbp
     ffe:	ff 54 24 68          	callq  *0x68(%rsp)
    1002:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%rsp)
    1009:	e9 5b 06 00 00       	jmpq   1669 <mxml_load_data+0x1036>
	  }
	}
      }
      else if (buffer[0] == '/')
    100e:	3c 2f                	cmp    $0x2f,%al
    1010:	0f 85 ab 00 00 00    	jne    10c1 <mxml_load_data+0xa8e>
      {
       /*
        * Handle close tag...
	*/

        if (!parent || strcmp(buffer + 1, parent->value.element.name))
    1016:	4d 85 ed             	test   %r13,%r13
    1019:	74 19                	je     1034 <mxml_load_data+0xa01>
    101b:	4d 8b 65 30          	mov    0x30(%r13),%r12
    101f:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
    1023:	4c 89 e6             	mov    %r12,%rsi
    1026:	e8 00 00 00 00       	callq  102b <mxml_load_data+0x9f8>
    102b:	85 c0                	test   %eax,%eax
    102d:	74 2a                	je     1059 <mxml_load_data+0xa26>
    102f:	e9 fc 07 00 00       	jmpq   1830 <mxml_load_data+0x11fd>
    1034:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 103b <mxml_load_data+0xa08>
	{
	 /*
	  * Close tag doesn't match tree; print an error for now...
	  */

	  mxml_error("Mismatched close tag <%s> under parent <%s>!",
    103b:	48 89 de             	mov    %rbx,%rsi
    103e:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1045 <mxml_load_data+0xa12>
    1045:	e9 40 fc ff ff       	jmpq   c8a <mxml_load_data+0x657>
       /*
        * Keep reading until we see >...
	*/

        while (ch != '>' && ch != EOF)
	  ch = (*getc_cb)(p, &encoding);
    104a:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    104f:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    1054:	41 ff d7             	callq  *%r15
    1057:	89 c5                	mov    %eax,%ebp

       /*
        * Keep reading until we see >...
	*/

        while (ch != '>' && ch != EOF)
    1059:	83 fd 3e             	cmp    $0x3e,%ebp
    105c:	74 04                	je     1062 <mxml_load_data+0xa2f>
    105e:	ff c5                	inc    %ebp
    1060:	75 e8                	jne    104a <mxml_load_data+0xa17>
	  ch = (*getc_cb)(p, &encoding);

        node   = parent;
        parent = parent->parent;

        if (sax_cb)
    1062:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)

        while (ch != '>' && ch != EOF)
	  ch = (*getc_cb)(p, &encoding);

        node   = parent;
        parent = parent->parent;
    1068:	49 8b 6d 18          	mov    0x18(%r13),%rbp

        if (sax_cb)
    106c:	74 29                	je     1097 <mxml_load_data+0xa64>
        {
          (*sax_cb)(node, MXML_SAX_ELEMENT_CLOSE, sax_data);
    106e:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
    1073:	be 04 00 00 00       	mov    $0x4,%esi
    1078:	4c 89 ef             	mov    %r13,%rdi
    107b:	ff 54 24 60          	callq  *0x60(%rsp)

          if (!mxmlRelease(node) && first == node)
    107f:	4c 89 ef             	mov    %r13,%rdi
    1082:	e8 00 00 00 00       	callq  1087 <mxml_load_data+0xa54>
    1087:	85 c0                	test   %eax,%eax
    1089:	75 0c                	jne    1097 <mxml_load_data+0xa64>
    108b:	4d 39 ee             	cmp    %r13,%r14
    108e:	b8 00 00 00 00       	mov    $0x0,%eax
    1093:	4c 0f 44 f0          	cmove  %rax,%r14

       /*
	* Ascend into the parent and set the value type as needed...
	*/

	if (cb && parent)
    1097:	80 bc 24 87 00 00 00 	cmpb   $0x0,0x87(%rsp)
    109e:	00 
    109f:	0f 84 c4 05 00 00    	je     1669 <mxml_load_data+0x1036>
    10a5:	48 85 ed             	test   %rbp,%rbp
    10a8:	0f 84 bb 05 00 00    	je     1669 <mxml_load_data+0x1036>
	  type = (*cb)(parent);
    10ae:	48 89 ef             	mov    %rbp,%rdi
    10b1:	ff 54 24 68          	callq  *0x68(%rsp)
    10b5:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%rsp)
    10bc:	e9 a8 05 00 00       	jmpq   1669 <mxml_load_data+0x1036>
      {
       /*
        * Handle open tag...
	*/

        if (!parent && first)
    10c1:	4d 85 ed             	test   %r13,%r13
    10c4:	75 11                	jne    10d7 <mxml_load_data+0xaa4>
    10c6:	4d 85 f6             	test   %r14,%r14
    10c9:	74 0c                	je     10d7 <mxml_load_data+0xaa4>
	{
	 /*
	  * There can only be one root element!
	  */

	  mxml_error("<%s> cannot be a second root node after <%s>",
    10cb:	49 8b 56 30          	mov    0x30(%r14),%rdx
    10cf:	48 89 de             	mov    %rbx,%rsi
    10d2:	e9 ac fb ff ff       	jmpq   c83 <mxml_load_data+0x650>
	             buffer, first->value.element.name);
          goto error;
	}

        if ((node = mxmlNewElement(parent, buffer)) == NULL)
    10d7:	48 89 de             	mov    %rbx,%rsi
    10da:	4c 89 ef             	mov    %r13,%rdi
    10dd:	e8 00 00 00 00       	callq  10e2 <mxml_load_data+0xaaf>
    10e2:	48 85 c0             	test   %rax,%rax
    10e5:	49 89 c4             	mov    %rax,%r12
    10e8:	75 23                	jne    110d <mxml_load_data+0xada>
	{
	 /*
	  * Just print error for now...
	  */

	  mxml_error("Unable to add element node to parent <%s>!",
    10ea:	4d 85 ed             	test   %r13,%r13
    10ed:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # 10f4 <mxml_load_data+0xac1>
    10f4:	74 04                	je     10fa <mxml_load_data+0xac7>
    10f6:	49 8b 75 30          	mov    0x30(%r13),%rsi
    10fa:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1101 <mxml_load_data+0xace>
    1101:	31 c0                	xor    %eax,%eax
    1103:	e8 00 00 00 00       	callq  1108 <mxml_load_data+0xad5>
    1108:	e9 82 06 00 00       	jmpq   178f <mxml_load_data+0x115c>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
    110d:	83 fd 20             	cmp    $0x20,%ebp
    1110:	74 13                	je     1125 <mxml_load_data+0xaf2>
    1112:	83 fd 09             	cmp    $0x9,%ebp
    1115:	74 0e                	je     1125 <mxml_load_data+0xaf2>
    1117:	83 fd 0d             	cmp    $0xd,%ebp
    111a:	74 09                	je     1125 <mxml_load_data+0xaf2>
    111c:	83 fd 0a             	cmp    $0xa,%ebp
    111f:	0f 85 b8 06 00 00    	jne    17dd <mxml_load_data+0x11aa>

 /*
  * Initialize the name and value buffers...
  */

  if ((name = malloc(64)) == NULL)
    1125:	bf 40 00 00 00       	mov    $0x40,%edi
    112a:	e8 00 00 00 00       	callq  112f <mxml_load_data+0xafc>
    112f:	48 85 c0             	test   %rax,%rax
    1132:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
    1139:	00 
    113a:	75 0c                	jne    1148 <mxml_load_data+0xb15>
  {
    mxml_error("Unable to allocate memory for name!");
    113c:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1143 <mxml_load_data+0xb10>
    1143:	e9 18 fb ff ff       	jmpq   c60 <mxml_load_data+0x62d>
    return (EOF);
  }

  namesize = 64;

  if ((value = malloc(64)) == NULL)
    1148:	bf 40 00 00 00       	mov    $0x40,%edi
  {
    mxml_error("Unable to allocate memory for name!");
    return (EOF);
  }

  namesize = 64;
    114d:	c7 84 24 cc 00 00 00 	movl   $0x40,0xcc(%rsp)
    1154:	40 00 00 00 

  if ((value = malloc(64)) == NULL)
    1158:	e8 00 00 00 00       	callq  115d <mxml_load_data+0xb2a>
    115d:	48 85 c0             	test   %rax,%rax
    1160:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
    1167:	00 
    1168:	75 19                	jne    1183 <mxml_load_data+0xb50>
  {
    free(name);
    116a:	48 8b bc 24 b0 00 00 	mov    0xb0(%rsp),%rdi
    1171:	00 
    1172:	e8 00 00 00 00       	callq  1177 <mxml_load_data+0xb44>
    mxml_error("Unable to allocate memory for value!");
    1177:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 117e <mxml_load_data+0xb4b>
    117e:	e9 db fa ff ff       	jmpq   c5e <mxml_load_data+0x62b>
	  {
	    if (ch == '&')
	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
	        goto error;

	    if (mxml_add_char(ch, &ptr, &value, &valsize))
    1183:	48 8d 94 24 c8 00 00 	lea    0xc8(%rsp),%rdx
    118a:	00 
    118b:	48 8d 84 24 a8 00 00 	lea    0xa8(%rsp),%rax
    1192:	00 
    free(name);
    mxml_error("Unable to allocate memory for value!");
    return (EOF);
  }

  valsize = 64;
    1193:	c7 84 24 c8 00 00 00 	movl   $0x40,0xc8(%rsp)
    119a:	40 00 00 00 
	  {
	    if (ch == '&')
	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
	        goto error;

	    if (mxml_add_char(ch, &ptr, &value, &valsize))
    119e:	48 89 54 24 38       	mov    %rdx,0x38(%rsp)
    11a3:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    11a8:	e9 a7 03 00 00       	jmpq   1554 <mxml_load_data+0xf21>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
    11ad:	83 fd 20             	cmp    $0x20,%ebp
    11b0:	0f 84 9e 03 00 00    	je     1554 <mxml_load_data+0xf21>
    11b6:	83 fd 09             	cmp    $0x9,%ebp
    11b9:	0f 84 95 03 00 00    	je     1554 <mxml_load_data+0xf21>
    11bf:	83 fd 0d             	cmp    $0xd,%ebp
    11c2:	0f 84 8c 03 00 00    	je     1554 <mxml_load_data+0xf21>
    11c8:	83 fd 0a             	cmp    $0xa,%ebp
    11cb:	0f 84 83 03 00 00    	je     1554 <mxml_load_data+0xf21>

   /*
    * Stop at /, ?, or >...
    */

    if (ch == '/' || ch == '?')
    11d1:	83 fd 2f             	cmp    $0x2f,%ebp
    11d4:	74 05                	je     11db <mxml_load_data+0xba8>
    11d6:	83 fd 3f             	cmp    $0x3f,%ebp
    11d9:	75 32                	jne    120d <mxml_load_data+0xbda>
    {
     /*
      * Grab the > character and print an error if it isn't there...
      */

      quote = (*getc_cb)(p, encoding);
    11db:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    11e0:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    11e5:	41 ff d7             	callq  *%r15

      if (quote != '>')
    11e8:	83 f8 3e             	cmp    $0x3e,%eax
    {
     /*
      * Grab the > character and print an error if it isn't there...
      */

      quote = (*getc_cb)(p, encoding);
    11eb:	89 c1                	mov    %eax,%ecx

      if (quote != '>')
    11ed:	0f 84 79 03 00 00    	je     156c <mxml_load_data+0xf39>
      {
        mxml_error("Expected '>' after '%c' for element %s, but got '%c'!",
    11f3:	49 8b 54 24 30       	mov    0x30(%r12),%rdx
    11f8:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 11ff <mxml_load_data+0xbcc>
    11ff:	89 ee                	mov    %ebp,%esi
    1201:	31 c0                	xor    %eax,%eax
    1203:	e8 00 00 00 00       	callq  1208 <mxml_load_data+0xbd5>
    1208:	e9 83 03 00 00       	jmpq   1590 <mxml_load_data+0xf5d>
        goto error;
      }

      break;
    }
    else if (ch == '<')
    120d:	83 fd 3c             	cmp    $0x3c,%ebp
    1210:	75 18                	jne    122a <mxml_load_data+0xbf7>
    {
      mxml_error("Bare < in element %s!", node->value.element.name);
    1212:	49 8b 74 24 30       	mov    0x30(%r12),%rsi
    1217:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 121e <mxml_load_data+0xbeb>
    121e:	31 c0                	xor    %eax,%eax
    1220:	e8 00 00 00 00       	callq  1225 <mxml_load_data+0xbf2>
    1225:	e9 66 03 00 00       	jmpq   1590 <mxml_load_data+0xf5d>
      goto error;
    }
    else if (ch == '>')
    122a:	83 fd 3e             	cmp    $0x3e,%ebp
    122d:	0f 84 39 03 00 00    	je     156c <mxml_load_data+0xf39>

   /*
    * Read the attribute name...
    */

    name[0] = ch;
    1233:	48 8b 84 24 b0 00 00 	mov    0xb0(%rsp),%rax
    123a:	00 
    123b:	40 88 28             	mov    %bpl,(%rax)
    ptr     = name + 1;
    123e:	48 8b 84 24 b0 00 00 	mov    0xb0(%rsp),%rax
    1245:	00 
    1246:	48 ff c0             	inc    %rax

    if (ch == '\"' || ch == '\'')
    1249:	83 fd 22             	cmp    $0x22,%ebp
   /*
    * Read the attribute name...
    */

    name[0] = ch;
    ptr     = name + 1;
    124c:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
    1253:	00 

    if (ch == '\"' || ch == '\'')
    1254:	74 56                	je     12ac <mxml_load_data+0xc79>
    1256:	83 fd 27             	cmp    $0x27,%ebp
    1259:	0f 85 ca 00 00 00    	jne    1329 <mxml_load_data+0xcf6>
    125f:	eb 4b                	jmp    12ac <mxml_load_data+0xc79>

      quote = ch;

      while ((ch = (*getc_cb)(p, encoding)) != EOF)
      {
        if (ch == '&')
    1261:	83 fb 26             	cmp    $0x26,%ebx
    1264:	75 20                	jne    1286 <mxml_load_data+0xc53>
	  if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
    1266:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    126b:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    1270:	4c 89 f9             	mov    %r15,%rcx
    1273:	4c 89 e7             	mov    %r12,%rdi
    1276:	e8 20 f1 ff ff       	callq  39b <mxml_get_entity>
    127b:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    127e:	89 c3                	mov    %eax,%ebx
    1280:	0f 84 0a 03 00 00    	je     1590 <mxml_load_data+0xf5d>
	    goto error;

	if (mxml_add_char(ch, &ptr, &name, &namesize))
    1286:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    128b:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
    1290:	89 df                	mov    %ebx,%edi
    1292:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    1297:	e8 62 f2 ff ff       	callq  4fe <mxml_add_char>
    129c:	85 c0                	test   %eax,%eax
    129e:	0f 85 ec 02 00 00    	jne    1590 <mxml_load_data+0xf5d>
	  goto error;

	if (ch == quote)
    12a4:	39 eb                	cmp    %ebp,%ebx
    12a6:	0f 84 91 00 00 00    	je     133d <mxml_load_data+0xd0a>
      * Name is in quotes, so get a quoted string...
      */

      quote = ch;

      while ((ch = (*getc_cb)(p, encoding)) != EOF)
    12ac:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    12b1:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    12b6:	41 ff d7             	callq  *%r15
    12b9:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    12bc:	89 c3                	mov    %eax,%ebx
    12be:	75 a1                	jne    1261 <mxml_load_data+0xc2e>
    12c0:	eb 7b                	jmp    133d <mxml_load_data+0xd0a>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
    12c2:	83 fb 20             	cmp    $0x20,%ebx
    12c5:	74 76                	je     133d <mxml_load_data+0xd0a>
    12c7:	83 fb 09             	cmp    $0x9,%ebx
    12ca:	74 71                	je     133d <mxml_load_data+0xd0a>
    12cc:	83 fb 0d             	cmp    $0xd,%ebx
    12cf:	74 6c                	je     133d <mxml_load_data+0xd0a>
    12d1:	83 fb 0a             	cmp    $0xa,%ebx
    12d4:	0f 85 11 05 00 00    	jne    17eb <mxml_load_data+0x11b8>
    12da:	eb 61                	jmp    133d <mxml_load_data+0xd0a>
     /*
      * Grab an normal, non-quoted name...
      */

      while ((ch = (*getc_cb)(p, encoding)) != EOF)
	if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>' ||
    12dc:	83 fb 3e             	cmp    $0x3e,%ebx
    12df:	74 5c                	je     133d <mxml_load_data+0xd0a>
    12e1:	83 fb 3f             	cmp    $0x3f,%ebx
    12e4:	74 57                	je     133d <mxml_load_data+0xd0a>
	    ch == '?')
          break;
	else
	{
          if (ch == '&')
    12e6:	83 fb 26             	cmp    $0x26,%ebx
    12e9:	75 20                	jne    130b <mxml_load_data+0xcd8>
	    if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
    12eb:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    12f0:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    12f5:	4c 89 f9             	mov    %r15,%rcx
    12f8:	4c 89 e7             	mov    %r12,%rdi
    12fb:	e8 9b f0 ff ff       	callq  39b <mxml_get_entity>
    1300:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1303:	89 c3                	mov    %eax,%ebx
    1305:	0f 84 85 02 00 00    	je     1590 <mxml_load_data+0xf5d>
	      goto error;

	  if (mxml_add_char(ch, &ptr, &name, &namesize))
    130b:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    1310:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
    1315:	89 df                	mov    %ebx,%edi
    1317:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    131c:	e8 dd f1 ff ff       	callq  4fe <mxml_add_char>
    1321:	85 c0                	test   %eax,%eax
    1323:	0f 85 67 02 00 00    	jne    1590 <mxml_load_data+0xf5d>
    {
     /*
      * Grab an normal, non-quoted name...
      */

      while ((ch = (*getc_cb)(p, encoding)) != EOF)
    1329:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    132e:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    1333:	41 ff d7             	callq  *%r15
    1336:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1339:	89 c3                	mov    %eax,%ebx
    133b:	75 85                	jne    12c2 <mxml_load_data+0xc8f>
	  if (mxml_add_char(ch, &ptr, &name, &namesize))
	    goto error;
	}
    }

    *ptr = '\0';
    133d:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
    1344:	00 

    if (mxmlElementGetAttr(node, name))
    1345:	4c 89 e7             	mov    %r12,%rdi
	  if (mxml_add_char(ch, &ptr, &name, &namesize))
	    goto error;
	}
    }

    *ptr = '\0';
    1348:	c6 00 00             	movb   $0x0,(%rax)

    if (mxmlElementGetAttr(node, name))
    134b:	48 8b b4 24 b0 00 00 	mov    0xb0(%rsp),%rsi
    1352:	00 
    1353:	e8 00 00 00 00       	callq  1358 <mxml_load_data+0xd25>
    1358:	48 85 c0             	test   %rax,%rax
    135b:	0f 85 2f 02 00 00    	jne    1590 <mxml_load_data+0xf5d>
      goto error;

    while (ch != EOF && mxml_isspace(ch))
    1361:	83 fb ff             	cmp    $0xffffffffffffffff,%ebx
    1364:	0f 84 9a 01 00 00    	je     1504 <mxml_load_data+0xed1>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
    136a:	83 fb 20             	cmp    $0x20,%ebx
    136d:	74 0f                	je     137e <mxml_load_data+0xd4b>
    136f:	83 fb 09             	cmp    $0x9,%ebx
    1372:	74 0a                	je     137e <mxml_load_data+0xd4b>
    1374:	83 fb 0d             	cmp    $0xd,%ebx
    1377:	74 05                	je     137e <mxml_load_data+0xd4b>
    1379:	83 fb 0a             	cmp    $0xa,%ebx
    137c:	75 11                	jne    138f <mxml_load_data+0xd5c>

    if (mxmlElementGetAttr(node, name))
      goto error;

    while (ch != EOF && mxml_isspace(ch))
      ch = (*getc_cb)(p, encoding);
    137e:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    1383:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    1388:	41 ff d7             	callq  *%r15
    138b:	89 c3                	mov    %eax,%ebx
    138d:	eb d2                	jmp    1361 <mxml_load_data+0xd2e>

    if (ch == '=')
    138f:	83 fb 3d             	cmp    $0x3d,%ebx
    1392:	0f 85 6c 01 00 00    	jne    1504 <mxml_load_data+0xed1>
    {
     /*
      * Read the attribute value...
      */

      while ((ch = (*getc_cb)(p, encoding)) != EOF && mxml_isspace(ch));
    1398:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    139d:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    13a2:	41 ff d7             	callq  *%r15
    13a5:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    13a8:	89 c3                	mov    %eax,%ebx
    13aa:	0f 84 54 01 00 00    	je     1504 <mxml_load_data+0xed1>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
    13b0:	83 f8 20             	cmp    $0x20,%eax
    13b3:	74 e3                	je     1398 <mxml_load_data+0xd65>
    13b5:	83 f8 09             	cmp    $0x9,%eax
    13b8:	74 de                	je     1398 <mxml_load_data+0xd65>
    13ba:	83 f8 0d             	cmp    $0xd,%eax
    13bd:	74 d9                	je     1398 <mxml_load_data+0xd65>
    13bf:	83 f8 0a             	cmp    $0xa,%eax
    13c2:	0f 85 3a 04 00 00    	jne    1802 <mxml_load_data+0x11cf>
    13c8:	eb ce                	jmp    1398 <mxml_load_data+0xd65>
       /*
        * Read quoted value...
	*/

        quote = ch;
	ptr   = value;
    13ca:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
    13d1:	00 
    13d2:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
    13d9:	00 
    13da:	eb 4b                	jmp    1427 <mxml_load_data+0xdf4>

        while ((ch = (*getc_cb)(p, encoding)) != EOF)
	  if (ch == quote)
    13dc:	39 dd                	cmp    %ebx,%ebp
    13de:	0f 84 f1 00 00 00    	je     14d5 <mxml_load_data+0xea2>
	    break;
	  else
	  {
	    if (ch == '&')
    13e4:	83 fd 26             	cmp    $0x26,%ebp
    13e7:	75 20                	jne    1409 <mxml_load_data+0xdd6>
	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
    13e9:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    13ee:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    13f3:	4c 89 f9             	mov    %r15,%rcx
    13f6:	4c 89 e7             	mov    %r12,%rdi
    13f9:	e8 9d ef ff ff       	callq  39b <mxml_get_entity>
    13fe:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1401:	89 c5                	mov    %eax,%ebp
    1403:	0f 84 87 01 00 00    	je     1590 <mxml_load_data+0xf5d>
	        goto error;

	    if (mxml_add_char(ch, &ptr, &value, &valsize))
    1409:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    140e:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    1413:	89 ef                	mov    %ebp,%edi
    1415:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    141a:	e8 df f0 ff ff       	callq  4fe <mxml_add_char>
    141f:	85 c0                	test   %eax,%eax
    1421:	0f 85 69 01 00 00    	jne    1590 <mxml_load_data+0xf5d>
	*/

        quote = ch;
	ptr   = value;

        while ((ch = (*getc_cb)(p, encoding)) != EOF)
    1427:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    142c:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    1431:	41 ff d7             	callq  *%r15
    1434:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1437:	89 c5                	mov    %eax,%ebp
    1439:	75 a1                	jne    13dc <mxml_load_data+0xda9>
    143b:	e9 95 00 00 00       	jmpq   14d5 <mxml_load_data+0xea2>
      {
       /*
        * Read unquoted value...
	*/

	value[0] = ch;
    1440:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
    1447:	00 
    1448:	88 18                	mov    %bl,(%rax)
	ptr      = value + 1;
    144a:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
    1451:	00 
    1452:	48 ff c0             	inc    %rax
    1455:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
    145c:	00 
    145d:	eb 62                	jmp    14c1 <mxml_load_data+0xe8e>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
    145f:	83 fd 20             	cmp    $0x20,%ebp
    1462:	74 71                	je     14d5 <mxml_load_data+0xea2>
    1464:	83 fd 09             	cmp    $0x9,%ebp
    1467:	74 6c                	je     14d5 <mxml_load_data+0xea2>
    1469:	83 fd 0d             	cmp    $0xd,%ebp
    146c:	74 67                	je     14d5 <mxml_load_data+0xea2>
    146e:	83 fd 0a             	cmp    $0xa,%ebp
    1471:	0f 85 a2 03 00 00    	jne    1819 <mxml_load_data+0x11e6>
    1477:	eb 5c                	jmp    14d5 <mxml_load_data+0xea2>

	value[0] = ch;
	ptr      = value + 1;

	while ((ch = (*getc_cb)(p, encoding)) != EOF)
	  if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>')
    1479:	83 fd 3e             	cmp    $0x3e,%ebp
    147c:	74 57                	je     14d5 <mxml_load_data+0xea2>
            break;
	  else
	  {
	    if (ch == '&')
    147e:	83 fd 26             	cmp    $0x26,%ebp
    1481:	75 20                	jne    14a3 <mxml_load_data+0xe70>
	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb)) == EOF)
    1483:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    1488:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    148d:	4c 89 f9             	mov    %r15,%rcx
    1490:	4c 89 e7             	mov    %r12,%rdi
    1493:	e8 03 ef ff ff       	callq  39b <mxml_get_entity>
    1498:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    149b:	89 c5                	mov    %eax,%ebp
    149d:	0f 84 ed 00 00 00    	je     1590 <mxml_load_data+0xf5d>
	        goto error;

	    if (mxml_add_char(ch, &ptr, &value, &valsize))
    14a3:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    14a8:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    14ad:	89 ef                	mov    %ebp,%edi
    14af:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
    14b4:	e8 45 f0 ff ff       	callq  4fe <mxml_add_char>
    14b9:	85 c0                	test   %eax,%eax
    14bb:	0f 85 cf 00 00 00    	jne    1590 <mxml_load_data+0xf5d>
	*/

	value[0] = ch;
	ptr      = value + 1;

	while ((ch = (*getc_cb)(p, encoding)) != EOF)
    14c1:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    14c6:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    14cb:	41 ff d7             	callq  *%r15
    14ce:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    14d1:	89 c5                	mov    %eax,%ebp
    14d3:	75 8a                	jne    145f <mxml_load_data+0xe2c>

	    if (mxml_add_char(ch, &ptr, &value, &valsize))
	      goto error;
	  }

        *ptr = '\0';
    14d5:	48 8b 84 24 a0 00 00 	mov    0xa0(%rsp),%rax
    14dc:	00 

     /*
      * Set the attribute with the given string value...
      */

      mxmlElementSetAttr(node, name, value);
    14dd:	4c 89 e7             	mov    %r12,%rdi

	    if (mxml_add_char(ch, &ptr, &value, &valsize))
	      goto error;
	  }

        *ptr = '\0';
    14e0:	c6 00 00             	movb   $0x0,(%rax)

     /*
      * Set the attribute with the given string value...
      */

      mxmlElementSetAttr(node, name, value);
    14e3:	48 8b 94 24 a8 00 00 	mov    0xa8(%rsp),%rdx
    14ea:	00 
    14eb:	48 8b b4 24 b0 00 00 	mov    0xb0(%rsp),%rsi
    14f2:	00 
    14f3:	e8 00 00 00 00       	callq  14f8 <mxml_load_data+0xec5>

   /*
    * Check the end character...
    */

    if (ch == '/' || ch == '?')
    14f8:	83 fd 2f             	cmp    $0x2f,%ebp
    14fb:	74 24                	je     1521 <mxml_load_data+0xeee>
    14fd:	83 fd 3f             	cmp    $0x3f,%ebp
    1500:	75 4d                	jne    154f <mxml_load_data+0xf1c>
    1502:	eb 1d                	jmp    1521 <mxml_load_data+0xeee>

      mxmlElementSetAttr(node, name, value);
    }
    else
    {
      mxml_error("Missing value for attribute '%s' in element %s!",
    1504:	49 8b 54 24 30       	mov    0x30(%r12),%rdx
    1509:	48 8b b4 24 b0 00 00 	mov    0xb0(%rsp),%rsi
    1510:	00 
    1511:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1518 <mxml_load_data+0xee5>
    1518:	31 c0                	xor    %eax,%eax
    151a:	e8 00 00 00 00       	callq  151f <mxml_load_data+0xeec>
    151f:	eb 6f                	jmp    1590 <mxml_load_data+0xf5d>
    {
     /*
      * Grab the > character and print an error if it isn't there...
      */

      quote = (*getc_cb)(p, encoding);
    1521:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    1526:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    152b:	41 ff d7             	callq  *%r15

      if (quote != '>')
    152e:	83 f8 3e             	cmp    $0x3e,%eax
    {
     /*
      * Grab the > character and print an error if it isn't there...
      */

      quote = (*getc_cb)(p, encoding);
    1531:	89 c1                	mov    %eax,%ecx

      if (quote != '>')
    1533:	74 37                	je     156c <mxml_load_data+0xf39>
      {
        mxml_error("Expected '>' after '%c' for element %s, but got '%c'!",
    1535:	49 8b 54 24 30       	mov    0x30(%r12),%rdx
    153a:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1541 <mxml_load_data+0xf0e>
    1541:	89 ee                	mov    %ebp,%esi
    1543:	31 c0                	xor    %eax,%eax
    1545:	83 cd ff             	or     $0xffffffffffffffff,%ebp
    1548:	e8 00 00 00 00       	callq  154d <mxml_load_data+0xf1a>
    154d:	eb 1d                	jmp    156c <mxml_load_data+0xf39>
        ch = EOF;
      }

      break;
    }
    else if (ch == '>')
    154f:	83 fd 3e             	cmp    $0x3e,%ebp
    1552:	74 18                	je     156c <mxml_load_data+0xf39>

 /*
  * Loop until we hit a >, /, ?, or EOF...
  */

  while ((ch = (*getc_cb)(p, encoding)) != EOF)
    1554:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    1559:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    155e:	41 ff d7             	callq  *%r15
    1561:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1564:	89 c5                	mov    %eax,%ebp
    1566:	0f 85 41 fc ff ff    	jne    11ad <mxml_load_data+0xb7a>

 /*
  * Free the name and value buffers and return...
  */

  free(name);
    156c:	48 8b bc 24 b0 00 00 	mov    0xb0(%rsp),%rdi
    1573:	00 
    1574:	e8 00 00 00 00       	callq  1579 <mxml_load_data+0xf46>
  free(value);
    1579:	48 8b bc 24 a8 00 00 	mov    0xa8(%rsp),%rdi
    1580:	00 
    1581:	e8 00 00 00 00       	callq  1586 <mxml_load_data+0xf53>
	  goto error;
	}

        if (mxml_isspace(ch))
        {
	  if ((ch = mxml_parse_element(node, p, &encoding, getc_cb)) == EOF)
    1586:	83 fd ff             	cmp    $0xffffffffffffffff,%ebp
    1589:	75 5b                	jne    15e6 <mxml_load_data+0xfb3>
    158b:	e9 ff 01 00 00       	jmpq   178f <mxml_load_data+0x115c>
  * Common error return point...
  */

error:

  free(name);
    1590:	48 8b bc 24 b0 00 00 	mov    0xb0(%rsp),%rdi
    1597:	00 
    1598:	e8 00 00 00 00       	callq  159d <mxml_load_data+0xf6a>
  free(value);
    159d:	48 8b bc 24 a8 00 00 	mov    0xa8(%rsp),%rdi
    15a4:	00 
    15a5:	e8 00 00 00 00       	callq  15aa <mxml_load_data+0xf77>
    15aa:	e9 e0 01 00 00       	jmpq   178f <mxml_load_data+0x115c>
	  if ((ch = mxml_parse_element(node, p, &encoding, getc_cb)) == EOF)
	    goto error;
        }
        else if (ch == '/')
	{
	  if ((ch = (*getc_cb)(p, &encoding)) != '>')
    15af:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    15b4:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    15b9:	41 ff d7             	callq  *%r15
    15bc:	83 f8 3e             	cmp    $0x3e,%eax
    15bf:	89 c6                	mov    %eax,%esi
    15c1:	74 23                	je     15e6 <mxml_load_data+0xfb3>
	  {
	    mxml_error("Expected > but got '%c' instead for element <%s/>!",
    15c3:	48 8b 94 24 c0 00 00 	mov    0xc0(%rsp),%rdx
    15ca:	00 
    15cb:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 15d2 <mxml_load_data+0xf9f>
    15d2:	31 c0                	xor    %eax,%eax
    15d4:	e8 00 00 00 00       	callq  15d9 <mxml_load_data+0xfa6>
	               ch, buffer);
            mxmlDelete(node);
    15d9:	4c 89 e7             	mov    %r12,%rdi
    15dc:	e8 00 00 00 00       	callq  15e1 <mxml_load_data+0xfae>
    15e1:	e9 a9 01 00 00       	jmpq   178f <mxml_load_data+0x115c>
	  }

	  ch = '/';
	}

        if (sax_cb)
    15e6:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
    15ec:	74 11                	je     15ff <mxml_load_data+0xfcc>
          (*sax_cb)(node, MXML_SAX_ELEMENT_OPEN, sax_data);
    15ee:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
    15f3:	be 05 00 00 00       	mov    $0x5,%esi
    15f8:	4c 89 e7             	mov    %r12,%rdi
    15fb:	ff 54 24 60          	callq  *0x60(%rsp)

        if (!first)
    15ff:	4d 85 f6             	test   %r14,%r14
    1602:	4d 0f 44 f4          	cmove  %r12,%r14
	  first = node;

	if (ch == EOF)
    1606:	83 fd ff             	cmp    $0xffffffffffffffff,%ebp
    1609:	0f 84 18 01 00 00    	je     1727 <mxml_load_data+0x10f4>
	  break;

        if (ch != '/')
    160f:	83 fd 2f             	cmp    $0x2f,%ebp
    1612:	74 20                	je     1634 <mxml_load_data+0x1001>
	  * Descend into this node, setting the value type as needed...
	  */

	  parent = node;

	  if (cb && parent)
    1614:	80 bc 24 87 00 00 00 	cmpb   $0x0,0x87(%rsp)
    161b:	00 
    161c:	4c 89 e5             	mov    %r12,%rbp
    161f:	74 48                	je     1669 <mxml_load_data+0x1036>
	    type = (*cb)(parent);
    1621:	4c 89 e7             	mov    %r12,%rdi
    1624:	4c 89 e5             	mov    %r12,%rbp
    1627:	ff 54 24 68          	callq  *0x68(%rsp)
    162b:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%rsp)
    1632:	eb 35                	jmp    1669 <mxml_load_data+0x1036>
	}
        else if (sax_cb)
    1634:	48 83 7c 24 60 00    	cmpq   $0x0,0x60(%rsp)
    163a:	74 2a                	je     1666 <mxml_load_data+0x1033>
        {
          (*sax_cb)(node, MXML_SAX_ELEMENT_CLOSE, sax_data);
    163c:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
    1641:	be 04 00 00 00       	mov    $0x4,%esi
    1646:	4c 89 e7             	mov    %r12,%rdi
    1649:	ff 54 24 60          	callq  *0x60(%rsp)

          if (!mxmlRelease(node) && first == node)
    164d:	4c 89 e7             	mov    %r12,%rdi
    1650:	e8 00 00 00 00       	callq  1655 <mxml_load_data+0x1022>
    1655:	85 c0                	test   %eax,%eax
    1657:	75 0d                	jne    1666 <mxml_load_data+0x1033>
    1659:	4d 39 e6             	cmp    %r12,%r14
    165c:	75 08                	jne    1666 <mxml_load_data+0x1033>
    165e:	4c 89 ed             	mov    %r13,%rbp
    1661:	45 31 f6             	xor    %r14d,%r14d
    1664:	eb 03                	jmp    1669 <mxml_load_data+0x1036>
    1666:	4c 89 ed             	mov    %r13,%rbp
            first = NULL;
        }
      }

      bufptr  = buffer;
    1669:	48 8b 84 24 c0 00 00 	mov    0xc0(%rsp),%rax
    1670:	00 
    1671:	49 89 ed             	mov    %rbp,%r13
    1674:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
    167b:	00 
    167c:	e9 8e 00 00 00       	jmpq   170f <mxml_load_data+0x10dc>
    }
    else if (ch == '&')
    1681:	83 fd 26             	cmp    $0x26,%ebp
    1684:	75 3a                	jne    16c0 <mxml_load_data+0x108d>
    {
     /*
      * Add character entity to current buffer...
      */

      if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb)) == EOF)
    1686:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    168b:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    1690:	4c 89 ef             	mov    %r13,%rdi
    1693:	4c 89 f9             	mov    %r15,%rcx
    1696:	e8 00 ed ff ff       	callq  39b <mxml_get_entity>
    169b:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    169e:	89 c7                	mov    %eax,%edi
    16a0:	0f 84 e9 00 00 00    	je     178f <mxml_load_data+0x115c>
	goto error;

      if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
    16a6:	48 8d 8c 24 d4 00 00 	lea    0xd4(%rsp),%rcx
    16ad:	00 
    16ae:	48 8d 94 24 c0 00 00 	lea    0xc0(%rsp),%rdx
    16b5:	00 
    16b6:	48 8d b4 24 b8 00 00 	lea    0xb8(%rsp),%rsi
    16bd:	00 
    16be:	eb 42                	jmp    1702 <mxml_load_data+0x10cf>
	goto error;
    }
    else if (type == MXML_OPAQUE || type == MXML_CUSTOM || !mxml_isspace(ch))
    16c0:	83 bc 24 8c 00 00 00 	cmpl   $0x2,0x8c(%rsp)
    16c7:	02 
    16c8:	74 1e                	je     16e8 <mxml_load_data+0x10b5>
    16ca:	83 bc 24 8c 00 00 00 	cmpl   $0x5,0x8c(%rsp)
    16d1:	05 
    16d2:	74 14                	je     16e8 <mxml_load_data+0x10b5>
static int		mxml_get_entity(mxml_node_t *parent, void *p,
			                int *encoding,
					_mxml_getc_cb_t getc_cb);
static inline int	mxml_isspace(int ch)
			{
			  return (ch == ' ' || ch == '\t' || ch == '\r' ||
    16d4:	83 fd 20             	cmp    $0x20,%ebp
    16d7:	74 36                	je     170f <mxml_load_data+0x10dc>
    16d9:	83 fd 09             	cmp    $0x9,%ebp
    16dc:	74 31                	je     170f <mxml_load_data+0x10dc>
    16de:	83 fd 0d             	cmp    $0xd,%ebp
    16e1:	74 2c                	je     170f <mxml_load_data+0x10dc>
    16e3:	83 fd 0a             	cmp    $0xa,%ebp
    16e6:	74 27                	je     170f <mxml_load_data+0x10dc>
    {
     /*
      * Add character to current buffer...
      */

      if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
    16e8:	48 8d 8c 24 d4 00 00 	lea    0xd4(%rsp),%rcx
    16ef:	00 
    16f0:	48 8d 94 24 c0 00 00 	lea    0xc0(%rsp),%rdx
    16f7:	00 
    16f8:	48 8d b4 24 b8 00 00 	lea    0xb8(%rsp),%rsi
    16ff:	00 
    1700:	89 ef                	mov    %ebp,%edi
    1702:	e8 f7 ed ff ff       	callq  4fe <mxml_add_char>
    1707:	85 c0                	test   %eax,%eax
    1709:	0f 85 80 00 00 00    	jne    178f <mxml_load_data+0x115c>
  else if (parent)
    type = MXML_TEXT;
  else
    type = MXML_IGNORE;

  while ((ch = (*getc_cb)(p, &encoding)) != EOF)
    170f:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    1714:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    1719:	41 ff d7             	callq  *%r15
    171c:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    171f:	89 c5                	mov    %eax,%ebp
    1721:	0f 85 29 f0 ff ff    	jne    750 <mxml_load_data+0x11d>

 /*
  * Free the string buffer - we don't need it anymore...
  */

  free(buffer);
    1727:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
    172e:	00 
    172f:	e8 00 00 00 00       	callq  1734 <mxml_load_data+0x1101>

 /*
  * Find the top element and return it...
  */

  if (parent)
    1734:	4d 85 ed             	test   %r13,%r13
    1737:	74 4d                	je     1786 <mxml_load_data+0x1153>
    1739:	4c 89 e8             	mov    %r13,%rax
  {
    node = parent;

    while (parent != top && parent->parent)
    173c:	48 3b 44 24 78       	cmp    0x78(%rsp),%rax
    1741:	74 0e                	je     1751 <mxml_load_data+0x111e>
    1743:	48 8b 50 18          	mov    0x18(%rax),%rdx
    1747:	48 85 d2             	test   %rdx,%rdx
    174a:	74 05                	je     1751 <mxml_load_data+0x111e>
    174c:	48 89 d0             	mov    %rdx,%rax
    174f:	eb eb                	jmp    173c <mxml_load_data+0x1109>
      parent = parent->parent;

    if (node != parent)
    1751:	49 39 c5             	cmp    %rax,%r13
    1754:	74 30                	je     1786 <mxml_load_data+0x1153>
    {
      mxml_error("Missing close tag </%s> under parent <%s>!",
    1756:	49 8b 45 18          	mov    0x18(%r13),%rax
    175a:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 1761 <mxml_load_data+0x112e>
    1761:	48 85 c0             	test   %rax,%rax
    1764:	74 04                	je     176a <mxml_load_data+0x1137>
    1766:	48 8b 50 30          	mov    0x30(%rax),%rdx
    176a:	49 8b 75 30          	mov    0x30(%r13),%rsi
    176e:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1775 <mxml_load_data+0x1142>
    1775:	31 c0                	xor    %eax,%eax
    1777:	e8 00 00 00 00       	callq  177c <mxml_load_data+0x1149>
	         node->value.element.name,
		 node->parent ? node->parent->value.element.name : "(null)");

      mxmlDelete(first);
    177c:	4c 89 f7             	mov    %r14,%rdi
    177f:	e8 00 00 00 00       	callq  1784 <mxml_load_data+0x1151>
    1784:	eb 1e                	jmp    17a4 <mxml_load_data+0x1171>

      return (NULL);
    }
  }

  if (parent)
    1786:	4d 85 ed             	test   %r13,%r13
    1789:	4d 0f 44 ee          	cmove  %r14,%r13
    178d:	eb 18                	jmp    17a7 <mxml_load_data+0x1174>
  * Common error return...
  */

error:

  mxmlDelete(first);
    178f:	4c 89 f7             	mov    %r14,%rdi
    1792:	e8 00 00 00 00       	callq  1797 <mxml_load_data+0x1164>

  free(buffer);
    1797:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
    179e:	00 
    179f:	e8 00 00 00 00       	callq  17a4 <mxml_load_data+0x1171>
    17a4:	45 31 ed             	xor    %r13d,%r13d

  return (NULL);
}
    17a7:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    17ae:	4c 89 e8             	mov    %r13,%rax
    17b1:	5b                   	pop    %rbx
    17b2:	5d                   	pop    %rbp
    17b3:	41 5c                	pop    %r12
    17b5:	41 5d                	pop    %r13
    17b7:	41 5e                	pop    %r14
    17b9:	41 5f                	pop    %r15
    17bb:	c3                   	retq   

error:

  mxmlDelete(first);

  free(buffer);
    17bc:	49 89 de             	mov    %rbx,%r14
    17bf:	c7 84 24 88 00 00 00 	movl   $0x0,0x88(%rsp)
    17c6:	00 00 00 00 
    17ca:	e9 a0 f2 ff ff       	jmpq   a6f <mxml_load_data+0x43c>
      */

      bufptr = buffer;

      while ((ch = (*getc_cb)(p, &encoding)) != EOF)
        if (mxml_isspace(ch) || ch == '>' || (ch == '/' && bufptr > buffer))
    17cf:	83 fd 3e             	cmp    $0x3e,%ebp
    17d2:	0f 85 f2 f2 ff ff    	jne    aca <mxml_load_data+0x497>
    17d8:	e9 dc f3 ff ff       	jmpq   bb9 <mxml_load_data+0x586>
        if (mxml_isspace(ch))
        {
	  if ((ch = mxml_parse_element(node, p, &encoding, getc_cb)) == EOF)
	    goto error;
        }
        else if (ch == '/')
    17dd:	83 fd 2f             	cmp    $0x2f,%ebp
    17e0:	0f 85 00 fe ff ff    	jne    15e6 <mxml_load_data+0xfb3>
    17e6:	e9 c4 fd ff ff       	jmpq   15af <mxml_load_data+0xf7c>
     /*
      * Grab an normal, non-quoted name...
      */

      while ((ch = (*getc_cb)(p, encoding)) != EOF)
	if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>' ||
    17eb:	83 fb 3d             	cmp    $0x3d,%ebx
    17ee:	0f 84 49 fb ff ff    	je     133d <mxml_load_data+0xd0a>
    17f4:	83 fb 2f             	cmp    $0x2f,%ebx
    17f7:	0f 85 df fa ff ff    	jne    12dc <mxml_load_data+0xca9>
    17fd:	e9 3b fb ff ff       	jmpq   133d <mxml_load_data+0xd0a>
        mxml_error("Missing value for attribute '%s' in element %s!",
	           name, node->value.element.name);
        goto error;
      }

      if (ch == '\'' || ch == '\"')
    1802:	83 f8 27             	cmp    $0x27,%eax
    1805:	0f 84 bf fb ff ff    	je     13ca <mxml_load_data+0xd97>
    180b:	83 f8 22             	cmp    $0x22,%eax
    180e:	0f 85 2c fc ff ff    	jne    1440 <mxml_load_data+0xe0d>
    1814:	e9 b1 fb ff ff       	jmpq   13ca <mxml_load_data+0xd97>

	value[0] = ch;
	ptr      = value + 1;

	while ((ch = (*getc_cb)(p, encoding)) != EOF)
	  if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>')
    1819:	83 fd 3d             	cmp    $0x3d,%ebp
    181c:	0f 84 b3 fc ff ff    	je     14d5 <mxml_load_data+0xea2>
    1822:	83 fd 2f             	cmp    $0x2f,%ebp
    1825:	0f 85 4e fc ff ff    	jne    1479 <mxml_load_data+0xe46>
    182b:	e9 a5 fc ff ff       	jmpq   14d5 <mxml_load_data+0xea2>
	{
	 /*
	  * Close tag doesn't match tree; print an error for now...
	  */

	  mxml_error("Mismatched close tag <%s> under parent <%s>!",
    1830:	4c 89 e2             	mov    %r12,%rdx
    1833:	e9 03 f8 ff ff       	jmpq   103b <mxml_load_data+0xa08>

0000000000001838 <mxmlSAXLoadString>:
    mxml_node_t    *top,		/* I - Top node */
    const char     *s,			/* I - String to load */
    mxml_load_cb_t cb,			/* I - Callback function or MXML_NO_CALLBACK */
    mxml_sax_cb_t  sax_cb,		/* I - SAX callback or MXML_NO_CALLBACK */
    void           *sax_data)		/* I - SAX user data */
{
    1838:	48 83 ec 08          	sub    $0x8,%rsp
 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, sax_cb, sax_data));
    183c:	4d 89 c1             	mov    %r8,%r9
    183f:	49 89 c8             	mov    %rcx,%r8
    1842:	48 8d 0d 83 e8 ff ff 	lea    -0x177d(%rip),%rcx        # cc <mxml_string_getc>
    mxml_node_t    *top,		/* I - Top node */
    const char     *s,			/* I - String to load */
    mxml_load_cb_t cb,			/* I - Callback function or MXML_NO_CALLBACK */
    mxml_sax_cb_t  sax_cb,		/* I - SAX callback or MXML_NO_CALLBACK */
    void           *sax_data)		/* I - SAX user data */
{
    1849:	48 89 34 24          	mov    %rsi,(%rsp)
 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, sax_cb, sax_data));
    184d:	48 89 e6             	mov    %rsp,%rsi
    1850:	e8 de ed ff ff       	callq  633 <mxml_load_data>
}
    1855:	41 59                	pop    %r9
    1857:	c3                   	retq   

0000000000001858 <mxmlSAXLoadFile>:
{
 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, fp, cb, mxml_file_getc, sax_cb, sax_data));
    1858:	4d 89 c1             	mov    %r8,%r9
    185b:	49 89 c8             	mov    %rcx,%r8
    185e:	48 8d 0d a3 00 00 00 	lea    0xa3(%rip),%rcx        # 1908 <mxml_file_getc>
    1865:	e9 c9 ed ff ff       	jmpq   633 <mxml_load_data>

000000000000186a <mxmlSAXLoadFd>:
mxmlSAXLoadFd(mxml_node_t    *top,	/* I - Top node */
              int            fd,	/* I - File descriptor to read from */
              mxml_load_cb_t cb,	/* I - Callback function or MXML_NO_CALLBACK */
              mxml_sax_cb_t  sax_cb,	/* I - SAX callback or MXML_NO_CALLBACK */
              void           *sax_data)	/* I - SAX user data */
{
    186a:	48 81 ec 28 20 00 00 	sub    $0x2028,%rsp

 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, sax_cb, sax_data));
    1871:	4d 89 c1             	mov    %r8,%r9
    1874:	49 89 c8             	mov    %rcx,%r8
 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
  buf.current = buf.buffer;
    1877:	48 8d 44 24 18       	lea    0x18(%rsp),%rax

 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, sax_cb, sax_data));
    187c:	48 8d 0d e6 03 00 00 	lea    0x3e6(%rip),%rcx        # 1c69 <mxml_fd_getc>

 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
    1883:	89 34 24             	mov    %esi,(%rsp)
  buf.current = buf.buffer;
    1886:	48 89 e6             	mov    %rsp,%rsi
    1889:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  buf.end     = buf.buffer;
    188e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)

 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, sax_cb, sax_data));
    1893:	e8 9b ed ff ff       	callq  633 <mxml_load_data>
}
    1898:	48 81 c4 28 20 00 00 	add    $0x2028,%rsp
    189f:	c3                   	retq   

00000000000018a0 <mxmlLoadString>:

mxml_node_t *				/* O - First node or NULL if the string has errors. */
mxmlLoadString(mxml_node_t    *top,	/* I - Top node */
               const char     *s,	/* I - String to load */
               mxml_load_cb_t cb)	/* I - Callback function or MXML_NO_CALLBACK */
{
    18a0:	48 83 ec 08          	sub    $0x8,%rsp
 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, MXML_NO_CALLBACK,
    18a4:	48 8d 0d 21 e8 ff ff 	lea    -0x17df(%rip),%rcx        # cc <mxml_string_getc>
    18ab:	45 31 c9             	xor    %r9d,%r9d

mxml_node_t *				/* O - First node or NULL if the string has errors. */
mxmlLoadString(mxml_node_t    *top,	/* I - Top node */
               const char     *s,	/* I - String to load */
               mxml_load_cb_t cb)	/* I - Callback function or MXML_NO_CALLBACK */
{
    18ae:	48 89 34 24          	mov    %rsi,(%rsp)
 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, MXML_NO_CALLBACK,
    18b2:	45 31 c0             	xor    %r8d,%r8d
    18b5:	48 89 e6             	mov    %rsp,%rsi
    18b8:	e8 76 ed ff ff       	callq  633 <mxml_load_data>
                         NULL));
}
    18bd:	41 5a                	pop    %r10
    18bf:	c3                   	retq   

00000000000018c0 <mxmlLoadFile>:
{
 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, fp, cb, mxml_file_getc, MXML_NO_CALLBACK, NULL));
    18c0:	48 8d 0d 41 00 00 00 	lea    0x41(%rip),%rcx        # 1908 <mxml_file_getc>
    18c7:	45 31 c9             	xor    %r9d,%r9d
    18ca:	45 31 c0             	xor    %r8d,%r8d
    18cd:	e9 61 ed ff ff       	jmpq   633 <mxml_load_data>

00000000000018d2 <mxmlLoadFd>:

mxml_node_t *				/* O - First node or NULL if the file could not be read. */
mxmlLoadFd(mxml_node_t    *top,		/* I - Top node */
           int            fd,		/* I - File descriptor to read from */
           mxml_load_cb_t cb)		/* I - Callback function or MXML_NO_CALLBACK */
{
    18d2:	48 81 ec 28 20 00 00 	sub    $0x2028,%rsp

 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, MXML_NO_CALLBACK, NULL));
    18d9:	48 8d 0d 89 03 00 00 	lea    0x389(%rip),%rcx        # 1c69 <mxml_fd_getc>
    18e0:	45 31 c9             	xor    %r9d,%r9d
 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
  buf.current = buf.buffer;
    18e3:	48 8d 44 24 18       	lea    0x18(%rsp),%rax

 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
    18e8:	89 34 24             	mov    %esi,(%rsp)

 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, MXML_NO_CALLBACK, NULL));
    18eb:	45 31 c0             	xor    %r8d,%r8d
 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
  buf.current = buf.buffer;
    18ee:	48 89 e6             	mov    %rsp,%rsi
    18f1:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  buf.end     = buf.buffer;
    18f6:	48 89 44 24 10       	mov    %rax,0x10(%rsp)

 /*
  * Read the XML data...
  */

  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, MXML_NO_CALLBACK, NULL));
    18fb:	e8 33 ed ff ff       	callq  633 <mxml_load_data>
}
    1900:	48 81 c4 28 20 00 00 	add    $0x2028,%rsp
    1907:	c3                   	retq   

0000000000001908 <mxml_file_getc>:
 */

static int				/* O  - Character or EOF */
mxml_file_getc(void *p,			/* I  - Pointer to file */
               int  *encoding)		/* IO - Encoding */
{
    1908:	41 55                	push   %r13
    190a:	49 89 fd             	mov    %rdi,%r13
    190d:	41 54                	push   %r12
    190f:	49 89 f4             	mov    %rsi,%r12
    1912:	55                   	push   %rbp
    1913:	53                   	push   %rbx
    1914:	48 83 ec 08          	sub    $0x8,%rsp
 /*
  * Read a character from the file and see if it is EOF or ASCII...
  */

  fp = (FILE *)p;
  ch = getc(fp);
    1918:	4c 89 ef             	mov    %r13,%rdi
    191b:	e8 00 00 00 00       	callq  1920 <mxml_file_getc+0x18>

  if (ch == EOF)
    1920:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
 /*
  * Read a character from the file and see if it is EOF or ASCII...
  */

  fp = (FILE *)p;
  ch = getc(fp);
    1923:	89 c5                	mov    %eax,%ebp

  if (ch == EOF)
    1925:	0f 84 de 02 00 00    	je     1c09 <mxml_file_getc+0x301>
    return (EOF);

  switch (*encoding)
    192b:	41 8b 04 24          	mov    (%r12),%eax
    192f:	83 f8 01             	cmp    $0x1,%eax
    1932:	0f 84 01 02 00 00    	je     1b39 <mxml_file_getc+0x231>
    1938:	83 f8 02             	cmp    $0x2,%eax
    193b:	0f 84 58 02 00 00    	je     1b99 <mxml_file_getc+0x291>
    1941:	85 c0                	test   %eax,%eax
    1943:	0f 85 c0 02 00 00    	jne    1c09 <mxml_file_getc+0x301>
    case ENCODE_UTF8 :
       /*
	* Got a UTF-8 character; convert UTF-8 to Unicode and return...
	*/

	if (!(ch & 0x80))
    1949:	40 84 ed             	test   %bpl,%bpl
    194c:	78 29                	js     1977 <mxml_file_getc+0x6f>
	{
	  if (mxml_bad_char(ch))
    194e:	83 fd 1f             	cmp    $0x1f,%ebp
    1951:	0f 8f b2 02 00 00    	jg     1c09 <mxml_file_getc+0x301>
    1957:	83 fd 0a             	cmp    $0xa,%ebp
    195a:	0f 84 a9 02 00 00    	je     1c09 <mxml_file_getc+0x301>
    1960:	83 fd 0d             	cmp    $0xd,%ebp
    1963:	0f 84 a0 02 00 00    	je     1c09 <mxml_file_getc+0x301>
    1969:	83 fd 09             	cmp    $0x9,%ebp
    196c:	0f 85 e8 01 00 00    	jne    1b5a <mxml_file_getc+0x252>
    1972:	e9 92 02 00 00       	jmpq   1c09 <mxml_file_getc+0x301>
          printf("mxml_file_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
#endif /* DEBUG > 1 */

	  return (ch);
        }
	else if (ch == 0xfe)
    1977:	81 fd fe 00 00 00    	cmp    $0xfe,%ebp
    197d:	75 20                	jne    199f <mxml_file_getc+0x97>
	{
	 /*
	  * UTF-16 big-endian BOM?
	  */

          ch = getc(fp);
    197f:	4c 89 ef             	mov    %r13,%rdi
    1982:	e8 00 00 00 00       	callq  1987 <mxml_file_getc+0x7f>
	  if (ch != 0xff)
    1987:	3d ff 00 00 00       	cmp    $0xff,%eax
    198c:	0f 85 74 02 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	    return (EOF);

	  *encoding = ENCODE_UTF16BE;
    1992:	41 c7 04 24 01 00 00 	movl   $0x1,(%r12)
    1999:	00 
    199a:	e9 79 ff ff ff       	jmpq   1918 <mxml_file_getc+0x10>

	  return (mxml_file_getc(p, encoding));
	}
	else if (ch == 0xff)
    199f:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
    19a5:	75 20                	jne    19c7 <mxml_file_getc+0xbf>
	{
	 /*
	  * UTF-16 little-endian BOM?
	  */

          ch = getc(fp);
    19a7:	4c 89 ef             	mov    %r13,%rdi
    19aa:	e8 00 00 00 00       	callq  19af <mxml_file_getc+0xa7>
	  if (ch != 0xfe)
    19af:	3d fe 00 00 00       	cmp    $0xfe,%eax
    19b4:	0f 85 4c 02 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	    return (EOF);

	  *encoding = ENCODE_UTF16LE;
    19ba:	41 c7 04 24 02 00 00 	movl   $0x2,(%r12)
    19c1:	00 
    19c2:	e9 51 ff ff ff       	jmpq   1918 <mxml_file_getc+0x10>

	  return (mxml_file_getc(p, encoding));
	}
	else if ((ch & 0xe0) == 0xc0)
    19c7:	89 e8                	mov    %ebp,%eax
    19c9:	25 e0 00 00 00       	and    $0xe0,%eax
    19ce:	3d c0 00 00 00       	cmp    $0xc0,%eax
    19d3:	75 34                	jne    1a09 <mxml_file_getc+0x101>
	{
	 /*
	  * Two-byte value...
	  */

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
    19d5:	4c 89 ef             	mov    %r13,%rdi
    19d8:	e8 00 00 00 00       	callq  19dd <mxml_file_getc+0xd5>
    19dd:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    19e0:	89 c2                	mov    %eax,%edx
    19e2:	0f 84 1e 02 00 00    	je     1c06 <mxml_file_getc+0x2fe>
    19e8:	25 c0 00 00 00       	and    $0xc0,%eax
    19ed:	83 c0 80             	add    $0xffffffffffffff80,%eax
    19f0:	0f 85 10 02 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	    return (EOF);

	  ch = ((ch & 0x1f) << 6) | (temp & 0x3f);
    19f6:	83 e5 1f             	and    $0x1f,%ebp
    19f9:	83 e2 3f             	and    $0x3f,%edx
    19fc:	c1 e5 06             	shl    $0x6,%ebp
    19ff:	09 d5                	or     %edx,%ebp

	  if (ch < 0x80)
    1a01:	83 fd 7f             	cmp    $0x7f,%ebp
    1a04:	e9 1f 01 00 00       	jmpq   1b28 <mxml_file_getc+0x220>
	  {
	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
	    return (EOF);
	  }
	}
	else if ((ch & 0xf0) == 0xe0)
    1a09:	89 e8                	mov    %ebp,%eax
    1a0b:	25 f0 00 00 00       	and    $0xf0,%eax
    1a10:	3d e0 00 00 00       	cmp    $0xe0,%eax
    1a15:	75 74                	jne    1a8b <mxml_file_getc+0x183>
	{
	 /*
	  * Three-byte value...
	  */

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
    1a17:	4c 89 ef             	mov    %r13,%rdi
    1a1a:	e8 00 00 00 00       	callq  1a1f <mxml_file_getc+0x117>
    1a1f:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1a22:	89 c3                	mov    %eax,%ebx
    1a24:	0f 84 dc 01 00 00    	je     1c06 <mxml_file_getc+0x2fe>
    1a2a:	25 c0 00 00 00       	and    $0xc0,%eax
    1a2f:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1a32:	0f 85 ce 01 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	    return (EOF);

	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
    1a38:	4c 89 ef             	mov    %r13,%rdi
    1a3b:	e8 00 00 00 00       	callq  1a40 <mxml_file_getc+0x138>
    1a40:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1a43:	89 c2                	mov    %eax,%edx
    1a45:	0f 84 bb 01 00 00    	je     1c06 <mxml_file_getc+0x2fe>
    1a4b:	25 c0 00 00 00       	and    $0xc0,%eax
    1a50:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1a53:	0f 85 ad 01 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	  */

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
    1a59:	83 e5 0f             	and    $0xf,%ebp

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1a5c:	83 e3 3f             	and    $0x3f,%ebx
	  */

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
    1a5f:	c1 e5 06             	shl    $0x6,%ebp

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1a62:	09 eb                	or     %ebp,%ebx
    1a64:	89 d5                	mov    %edx,%ebp
    1a66:	c1 e3 06             	shl    $0x6,%ebx
    1a69:	83 e5 3f             	and    $0x3f,%ebp
    1a6c:	09 dd                	or     %ebx,%ebp

	  if (ch < 0x800)
    1a6e:	81 fd ff 07 00 00    	cmp    $0x7ff,%ebp
    1a74:	0f 8e b4 00 00 00    	jle    1b2e <mxml_file_getc+0x226>

         /*
	  * Ignore (strip) Byte Order Mark (BOM)...
	  */

	  if (ch == 0xfeff)
    1a7a:	81 fd ff fe 00 00    	cmp    $0xfeff,%ebp
    1a80:	0f 84 92 fe ff ff    	je     1918 <mxml_file_getc+0x10>
    1a86:	e9 7e 01 00 00       	jmpq   1c09 <mxml_file_getc+0x301>
	    return (mxml_file_getc(p, encoding));
	}
	else if ((ch & 0xf8) == 0xf0)
    1a8b:	89 e8                	mov    %ebp,%eax
    1a8d:	25 f8 00 00 00       	and    $0xf8,%eax
    1a92:	3d f0 00 00 00       	cmp    $0xf0,%eax
    1a97:	0f 85 69 01 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	{
	 /*
	  * Four-byte value...
	  */

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
    1a9d:	4c 89 ef             	mov    %r13,%rdi
    1aa0:	e8 00 00 00 00       	callq  1aa5 <mxml_file_getc+0x19d>
    1aa5:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1aa8:	41 89 c4             	mov    %eax,%r12d
    1aab:	0f 84 55 01 00 00    	je     1c06 <mxml_file_getc+0x2fe>
    1ab1:	25 c0 00 00 00       	and    $0xc0,%eax
    1ab6:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1ab9:	0f 85 47 01 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	    return (EOF);

	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
    1abf:	4c 89 ef             	mov    %r13,%rdi
    1ac2:	e8 00 00 00 00       	callq  1ac7 <mxml_file_getc+0x1bf>
    1ac7:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1aca:	89 c3                	mov    %eax,%ebx
    1acc:	0f 84 34 01 00 00    	je     1c06 <mxml_file_getc+0x2fe>
    1ad2:	25 c0 00 00 00       	and    $0xc0,%eax
    1ad7:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1ada:	0f 85 26 01 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
    1ae0:	4c 89 ef             	mov    %r13,%rdi
    1ae3:	e8 00 00 00 00       	callq  1ae8 <mxml_file_getc+0x1e0>
    1ae8:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    1aeb:	89 c2                	mov    %eax,%edx
    1aed:	0f 84 13 01 00 00    	je     1c06 <mxml_file_getc+0x2fe>
    1af3:	25 c0 00 00 00       	and    $0xc0,%eax
    1af8:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1afb:	0f 85 05 01 00 00    	jne    1c06 <mxml_file_getc+0x2fe>
	  */

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
    1b01:	83 e5 07             	and    $0x7,%ebp

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1b04:	41 83 e4 3f          	and    $0x3f,%r12d
    1b08:	83 e3 3f             	and    $0x3f,%ebx
	  */

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
    1b0b:	c1 e5 06             	shl    $0x6,%ebp

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1b0e:	41 09 ec             	or     %ebp,%r12d

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1b11:	89 d5                	mov    %edx,%ebp
	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1b13:	41 c1 e4 06          	shl    $0x6,%r12d

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1b17:	83 e5 3f             	and    $0x3f,%ebp
	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1b1a:	44 09 e3             	or     %r12d,%ebx

	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1b1d:	c1 e3 06             	shl    $0x6,%ebx
    1b20:	09 dd                	or     %ebx,%ebp

	  if (ch < 0x10000)
    1b22:	81 fd ff ff 00 00    	cmp    $0xffff,%ebp
    1b28:	0f 8f db 00 00 00    	jg     1c09 <mxml_file_getc+0x301>
	  {
	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
    1b2e:	89 ee                	mov    %ebp,%esi
    1b30:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1b37 <mxml_file_getc+0x22f>
    1b37:	eb 2a                	jmp    1b63 <mxml_file_getc+0x25b>
    case ENCODE_UTF16BE :
       /*
        * Read UTF-16 big-endian char...
	*/

	ch = (ch << 8) | getc(fp);
    1b39:	c1 e5 08             	shl    $0x8,%ebp
    1b3c:	4c 89 ef             	mov    %r13,%rdi
    1b3f:	e8 00 00 00 00       	callq  1b44 <mxml_file_getc+0x23c>
    1b44:	09 c5                	or     %eax,%ebp

	if (mxml_bad_char(ch))
    1b46:	83 fd 1f             	cmp    $0x1f,%ebp
    1b49:	7f 24                	jg     1b6f <mxml_file_getc+0x267>
    1b4b:	83 fd 0a             	cmp    $0xa,%ebp
    1b4e:	74 1f                	je     1b6f <mxml_file_getc+0x267>
    1b50:	83 fd 0d             	cmp    $0xd,%ebp
    1b53:	74 1a                	je     1b6f <mxml_file_getc+0x267>
    1b55:	83 fd 09             	cmp    $0x9,%ebp
    1b58:	74 15                	je     1b6f <mxml_file_getc+0x267>
	{
	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
    1b5a:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1b61 <mxml_file_getc+0x259>
    1b61:	89 ee                	mov    %ebp,%esi
    1b63:	31 c0                	xor    %eax,%eax
    1b65:	e8 00 00 00 00       	callq  1b6a <mxml_file_getc+0x262>
    1b6a:	e9 97 00 00 00       	jmpq   1c06 <mxml_file_getc+0x2fe>
        	     ch);
	  return (EOF);
	}
        else if (ch >= 0xd800 && ch <= 0xdbff)
    1b6f:	8d 85 00 28 ff ff    	lea    -0xd800(%rbp),%eax
    1b75:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    1b7a:	0f 87 89 00 00 00    	ja     1c09 <mxml_file_getc+0x301>
	{
	 /*
	  * Multi-word UTF-16 char...
	  */

          int lch = getc(fp);
    1b80:	4c 89 ef             	mov    %r13,%rdi
    1b83:	e8 00 00 00 00       	callq  1b88 <mxml_file_getc+0x280>
          lch = (lch << 8) | getc(fp);
    1b88:	4c 89 ef             	mov    %r13,%rdi
	{
	 /*
	  * Multi-word UTF-16 char...
	  */

          int lch = getc(fp);
    1b8b:	89 c3                	mov    %eax,%ebx
          lch = (lch << 8) | getc(fp);
    1b8d:	c1 e3 08             	shl    $0x8,%ebx
    1b90:	e8 00 00 00 00       	callq  1b95 <mxml_file_getc+0x28d>
    1b95:	89 c2                	mov    %eax,%edx
    1b97:	eb 45                	jmp    1bde <mxml_file_getc+0x2d6>
    case ENCODE_UTF16LE :
       /*
        * Read UTF-16 little-endian char...
	*/

	ch |= (getc(fp) << 8);
    1b99:	4c 89 ef             	mov    %r13,%rdi
    1b9c:	e8 00 00 00 00       	callq  1ba1 <mxml_file_getc+0x299>
    1ba1:	c1 e0 08             	shl    $0x8,%eax
    1ba4:	09 c5                	or     %eax,%ebp

        if (mxml_bad_char(ch))
    1ba6:	83 fd 1f             	cmp    $0x1f,%ebp
    1ba9:	7f 0f                	jg     1bba <mxml_file_getc+0x2b2>
    1bab:	83 fd 0a             	cmp    $0xa,%ebp
    1bae:	74 0a                	je     1bba <mxml_file_getc+0x2b2>
    1bb0:	83 fd 0d             	cmp    $0xd,%ebp
    1bb3:	74 05                	je     1bba <mxml_file_getc+0x2b2>
    1bb5:	83 fd 09             	cmp    $0x9,%ebp
    1bb8:	75 a0                	jne    1b5a <mxml_file_getc+0x252>
	{
	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
        	     ch);
	  return (EOF);
	}
        else if (ch >= 0xd800 && ch <= 0xdbff)
    1bba:	8d 85 00 28 ff ff    	lea    -0xd800(%rbp),%eax
    1bc0:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    1bc5:	77 42                	ja     1c09 <mxml_file_getc+0x301>
	{
	 /*
	  * Multi-word UTF-16 char...
	  */

          int lch = getc(fp);
    1bc7:	4c 89 ef             	mov    %r13,%rdi
    1bca:	e8 00 00 00 00       	callq  1bcf <mxml_file_getc+0x2c7>
          lch |= (getc(fp) << 8);
    1bcf:	4c 89 ef             	mov    %r13,%rdi
	{
	 /*
	  * Multi-word UTF-16 char...
	  */

          int lch = getc(fp);
    1bd2:	89 c3                	mov    %eax,%ebx
          lch |= (getc(fp) << 8);
    1bd4:	e8 00 00 00 00       	callq  1bd9 <mxml_file_getc+0x2d1>
    1bd9:	89 c2                	mov    %eax,%edx
    1bdb:	c1 e2 08             	shl    $0x8,%edx
    1bde:	09 da                	or     %ebx,%edx

          if (lch < 0xdc00 || lch >= 0xdfff)
    1be0:	8d 82 00 24 ff ff    	lea    -0xdc00(%rdx),%eax
    1be6:	3d fe 03 00 00       	cmp    $0x3fe,%eax
    1beb:	77 19                	ja     1c06 <mxml_file_getc+0x2fe>
	    return (EOF);

          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
    1bed:	81 e5 ff 03 00 00    	and    $0x3ff,%ebp
    1bf3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    1bf9:	c1 e5 0a             	shl    $0xa,%ebp
    1bfc:	09 ea                	or     %ebp,%edx
    1bfe:	8d aa 00 00 01 00    	lea    0x10000(%rdx),%ebp
    1c04:	eb 03                	jmp    1c09 <mxml_file_getc+0x301>
    1c06:	83 cd ff             	or     $0xffffffffffffffff,%ebp
#if DEBUG > 1
  printf("mxml_file_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
#endif /* DEBUG > 1 */

  return (ch);
}
    1c09:	41 5b                	pop    %r11
    1c0b:	5b                   	pop    %rbx
    1c0c:	89 e8                	mov    %ebp,%eax
    1c0e:	5d                   	pop    %rbp
    1c0f:	41 5c                	pop    %r12
    1c11:	41 5d                	pop    %r13
    1c13:	c3                   	retq   

0000000000001c14 <mxml_fd_read>:
 * 'mxml_fd_read()' - Read a buffer of data from a file descriptor.
 */

static int				/* O - 0 on success, -1 on error */
mxml_fd_read(_mxml_fdbuf_t *buf)		/* I - File descriptor buffer */
{
    1c14:	55                   	push   %rbp

 /*
  * Read from the file descriptor...
  */

  while ((bytes = read(buf->fd, buf->buffer, sizeof(buf->buffer))) < 0)
    1c15:	48 8d 6f 18          	lea    0x18(%rdi),%rbp
 * 'mxml_fd_read()' - Read a buffer of data from a file descriptor.
 */

static int				/* O - 0 on success, -1 on error */
mxml_fd_read(_mxml_fdbuf_t *buf)		/* I - File descriptor buffer */
{
    1c19:	53                   	push   %rbx
    1c1a:	48 89 fb             	mov    %rdi,%rbx
    1c1d:	48 83 ec 08          	sub    $0x8,%rsp

 /*
  * Range check input...
  */

  if (!buf)
    1c21:	48 85 ff             	test   %rdi,%rdi
    1c24:	75 13                	jne    1c39 <mxml_fd_read+0x25>
    1c26:	eb 3a                	jmp    1c62 <mxml_fd_read+0x4e>
  * Read from the file descriptor...
  */

  while ((bytes = read(buf->fd, buf->buffer, sizeof(buf->buffer))) < 0)
#ifdef EINTR
    if (errno != EAGAIN && errno != EINTR)
    1c28:	e8 00 00 00 00       	callq  1c2d <mxml_fd_read+0x19>
    1c2d:	8b 00                	mov    (%rax),%eax
    1c2f:	83 f8 0b             	cmp    $0xb,%eax
    1c32:	74 05                	je     1c39 <mxml_fd_read+0x25>
    1c34:	83 f8 04             	cmp    $0x4,%eax
    1c37:	75 29                	jne    1c62 <mxml_fd_read+0x4e>

 /*
  * Read from the file descriptor...
  */

  while ((bytes = read(buf->fd, buf->buffer, sizeof(buf->buffer))) < 0)
    1c39:	8b 3b                	mov    (%rbx),%edi
    1c3b:	ba 00 20 00 00       	mov    $0x2000,%edx
    1c40:	48 89 ee             	mov    %rbp,%rsi
    1c43:	e8 00 00 00 00       	callq  1c48 <mxml_fd_read+0x34>
    1c48:	83 f8 00             	cmp    $0x0,%eax
    1c4b:	7c db                	jl     1c28 <mxml_fd_read+0x14>
#else
    if (errno != EAGAIN)
#endif /* EINTR */
      return (-1);

  if (bytes == 0)
    1c4d:	74 13                	je     1c62 <mxml_fd_read+0x4e>
 /*
  * Update the pointers and return success...
  */

  buf->current = buf->buffer;
  buf->end     = buf->buffer + bytes;
    1c4f:	48 98                	cltq   

 /*
  * Update the pointers and return success...
  */

  buf->current = buf->buffer;
    1c51:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
  buf->end     = buf->buffer + bytes;
    1c55:	48 8d 44 03 18       	lea    0x18(%rbx,%rax,1),%rax
    1c5a:	48 89 43 10          	mov    %rax,0x10(%rbx)
    1c5e:	31 c0                	xor    %eax,%eax
    1c60:	eb 03                	jmp    1c65 <mxml_fd_read+0x51>

  return (0);
    1c62:	83 c8 ff             	or     $0xffffffffffffffff,%eax
}
    1c65:	5b                   	pop    %rbx
    1c66:	5b                   	pop    %rbx
    1c67:	5d                   	pop    %rbp
    1c68:	c3                   	retq   

0000000000001c69 <mxml_fd_getc>:
 */

static int				/* O  - Character or EOF */
mxml_fd_getc(void *p,			/* I  - File descriptor buffer */
             int  *encoding)		/* IO - Encoding */
{
    1c69:	41 55                	push   %r13
    1c6b:	49 89 f5             	mov    %rsi,%r13
    1c6e:	41 54                	push   %r12
    1c70:	55                   	push   %rbp
    1c71:	48 89 fd             	mov    %rdi,%rbp
    1c74:	53                   	push   %rbx
    1c75:	48 83 ec 08          	sub    $0x8,%rsp
  * Grab the next character in the buffer...
  */

  buf = (_mxml_fdbuf_t *)p;

  if (buf->current >= buf->end)
    1c79:	48 8b 45 10          	mov    0x10(%rbp),%rax
    1c7d:	48 39 45 08          	cmp    %rax,0x8(%rbp)
    1c81:	72 10                	jb     1c93 <mxml_fd_getc+0x2a>
    if (mxml_fd_read(buf) < 0)
    1c83:	48 89 ef             	mov    %rbp,%rdi
    1c86:	e8 89 ff ff ff       	callq  1c14 <mxml_fd_read>
    1c8b:	85 c0                	test   %eax,%eax
    1c8d:	0f 88 68 04 00 00    	js     20fb <mxml_fd_getc+0x492>
      return (EOF);

  ch = *(buf->current)++;
    1c93:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1c97:	0f b6 18             	movzbl (%rax),%ebx
    1c9a:	48 8d 50 01          	lea    0x1(%rax),%rdx

  switch (*encoding)
    1c9e:	41 8b 45 00          	mov    0x0(%r13),%eax

  if (buf->current >= buf->end)
    if (mxml_fd_read(buf) < 0)
      return (EOF);

  ch = *(buf->current)++;
    1ca2:	48 89 55 08          	mov    %rdx,0x8(%rbp)

  switch (*encoding)
    1ca6:	83 f8 01             	cmp    $0x1,%eax
    1ca9:	0f 84 b0 02 00 00    	je     1f5f <mxml_fd_getc+0x2f6>
    1caf:	83 f8 02             	cmp    $0x2,%eax
    1cb2:	0f 84 78 03 00 00    	je     2030 <mxml_fd_getc+0x3c7>
    1cb8:	85 c0                	test   %eax,%eax
    1cba:	0f 85 3e 04 00 00    	jne    20fe <mxml_fd_getc+0x495>
    case ENCODE_UTF8 :
       /*
	* Got a UTF-8 character; convert UTF-8 to Unicode and return...
	*/

	if (!(ch & 0x80))
    1cc0:	84 db                	test   %bl,%bl
    1cc2:	78 29                	js     1ced <mxml_fd_getc+0x84>
	{
#if DEBUG > 1
          printf("mxml_fd_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
#endif /* DEBUG > 1 */

	  if (mxml_bad_char(ch))
    1cc4:	83 fb 1f             	cmp    $0x1f,%ebx
    1cc7:	0f 8f 31 04 00 00    	jg     20fe <mxml_fd_getc+0x495>
    1ccd:	83 fb 0a             	cmp    $0xa,%ebx
    1cd0:	0f 84 28 04 00 00    	je     20fe <mxml_fd_getc+0x495>
    1cd6:	83 fb 0d             	cmp    $0xd,%ebx
    1cd9:	0f 84 1f 04 00 00    	je     20fe <mxml_fd_getc+0x495>
    1cdf:	83 fb 09             	cmp    $0x9,%ebx
    1ce2:	0f 85 85 03 00 00    	jne    206d <mxml_fd_getc+0x404>
    1ce8:	e9 11 04 00 00       	jmpq   20fe <mxml_fd_getc+0x495>
	    return (EOF);
	  }

	  return (ch);
        }
	else if (ch == 0xfe)
    1ced:	81 fb fe 00 00 00    	cmp    $0xfe,%ebx
    1cf3:	75 38                	jne    1d2d <mxml_fd_getc+0xc4>
	{
	 /*
	  * UTF-16 big-endian BOM?
	  */

	  if (buf->current >= buf->end)
    1cf5:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1cf9:	72 10                	jb     1d0b <mxml_fd_getc+0xa2>
	    if (mxml_fd_read(buf) < 0)
    1cfb:	48 89 ef             	mov    %rbp,%rdi
    1cfe:	e8 11 ff ff ff       	callq  1c14 <mxml_fd_read>
    1d03:	85 c0                	test   %eax,%eax
    1d05:	0f 88 f0 03 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  ch = *(buf->current)++;
    1d0b:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1d0f:	8a 10                	mov    (%rax),%dl
    1d11:	48 ff c0             	inc    %rax
    1d14:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if (ch != 0xff)
    1d18:	fe c2                	inc    %dl
    1d1a:	0f 85 db 03 00 00    	jne    20fb <mxml_fd_getc+0x492>
	    return (EOF);

	  *encoding = ENCODE_UTF16BE;
    1d20:	41 c7 45 00 01 00 00 	movl   $0x1,0x0(%r13)
    1d27:	00 
    1d28:	e9 4c ff ff ff       	jmpq   1c79 <mxml_fd_getc+0x10>

	  return (mxml_fd_getc(p, encoding));
	}
	else if (ch == 0xff)
    1d2d:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
    1d33:	75 39                	jne    1d6e <mxml_fd_getc+0x105>
	{
	 /*
	  * UTF-16 little-endian BOM?
	  */

	  if (buf->current >= buf->end)
    1d35:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1d39:	72 10                	jb     1d4b <mxml_fd_getc+0xe2>
	    if (mxml_fd_read(buf) < 0)
    1d3b:	48 89 ef             	mov    %rbp,%rdi
    1d3e:	e8 d1 fe ff ff       	callq  1c14 <mxml_fd_read>
    1d43:	85 c0                	test   %eax,%eax
    1d45:	0f 88 b0 03 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  ch = *(buf->current)++;
    1d4b:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1d4f:	8a 10                	mov    (%rax),%dl
    1d51:	48 ff c0             	inc    %rax
    1d54:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if (ch != 0xfe)
    1d58:	80 fa fe             	cmp    $0xfe,%dl
    1d5b:	0f 85 9a 03 00 00    	jne    20fb <mxml_fd_getc+0x492>
	    return (EOF);

	  *encoding = ENCODE_UTF16LE;
    1d61:	41 c7 45 00 02 00 00 	movl   $0x2,0x0(%r13)
    1d68:	00 
    1d69:	e9 0b ff ff ff       	jmpq   1c79 <mxml_fd_getc+0x10>

	  return (mxml_fd_getc(p, encoding));
	}
	else if ((ch & 0xe0) == 0xc0)
    1d6e:	89 d8                	mov    %ebx,%eax
    1d70:	25 e0 00 00 00       	and    $0xe0,%eax
    1d75:	3d c0 00 00 00       	cmp    $0xc0,%eax
    1d7a:	75 47                	jne    1dc3 <mxml_fd_getc+0x15a>
	{
	 /*
	  * Two-byte value...
	  */

	  if (buf->current >= buf->end)
    1d7c:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1d80:	72 10                	jb     1d92 <mxml_fd_getc+0x129>
	    if (mxml_fd_read(buf) < 0)
    1d82:	48 89 ef             	mov    %rbp,%rdi
    1d85:	e8 8a fe ff ff       	callq  1c14 <mxml_fd_read>
    1d8a:	85 c0                	test   %eax,%eax
    1d8c:	0f 88 69 03 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    1d92:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1d96:	0f b6 10             	movzbl (%rax),%edx
    1d99:	48 ff c0             	inc    %rax
    1d9c:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if ((temp & 0xc0) != 0x80)
    1da0:	89 d0                	mov    %edx,%eax
    1da2:	25 c0 00 00 00       	and    $0xc0,%eax
    1da7:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1daa:	0f 85 4b 03 00 00    	jne    20fb <mxml_fd_getc+0x492>
	    return (EOF);

	  ch = ((ch & 0x1f) << 6) | (temp & 0x3f);
    1db0:	83 e3 1f             	and    $0x1f,%ebx
    1db3:	83 e2 3f             	and    $0x3f,%edx
    1db6:	c1 e3 06             	shl    $0x6,%ebx
    1db9:	09 d3                	or     %edx,%ebx

	  if (ch < 0x80)
    1dbb:	83 fb 7f             	cmp    $0x7f,%ebx
    1dbe:	e9 88 01 00 00       	jmpq   1f4b <mxml_fd_getc+0x2e2>
	  {
	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
	    return (EOF);
	  }
	}
	else if ((ch & 0xf0) == 0xe0)
    1dc3:	89 d8                	mov    %ebx,%eax
    1dc5:	25 f0 00 00 00       	and    $0xf0,%eax
    1dca:	3d e0 00 00 00       	cmp    $0xe0,%eax
    1dcf:	0f 85 9d 00 00 00    	jne    1e72 <mxml_fd_getc+0x209>
	{
	 /*
	  * Three-byte value...
	  */

	  if (buf->current >= buf->end)
    1dd5:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1dd9:	72 10                	jb     1deb <mxml_fd_getc+0x182>
	    if (mxml_fd_read(buf) < 0)
    1ddb:	48 89 ef             	mov    %rbp,%rdi
    1dde:	e8 31 fe ff ff       	callq  1c14 <mxml_fd_read>
    1de3:	85 c0                	test   %eax,%eax
    1de5:	0f 88 10 03 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    1deb:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1def:	44 0f b6 20          	movzbl (%rax),%r12d
    1df3:	48 8d 50 01          	lea    0x1(%rax),%rdx
    1df7:	48 89 55 08          	mov    %rdx,0x8(%rbp)

	  if ((temp & 0xc0) != 0x80)
    1dfb:	44 89 e0             	mov    %r12d,%eax
    1dfe:	25 c0 00 00 00       	and    $0xc0,%eax
    1e03:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1e06:	0f 85 ef 02 00 00    	jne    20fb <mxml_fd_getc+0x492>
	    return (EOF);

	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);

	  if (buf->current >= buf->end)
    1e0c:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1e10:	72 10                	jb     1e22 <mxml_fd_getc+0x1b9>
	    if (mxml_fd_read(buf) < 0)
    1e12:	48 89 ef             	mov    %rbp,%rdi
    1e15:	e8 fa fd ff ff       	callq  1c14 <mxml_fd_read>
    1e1a:	85 c0                	test   %eax,%eax
    1e1c:	0f 88 d9 02 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    1e22:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1e26:	0f b6 10             	movzbl (%rax),%edx
    1e29:	48 ff c0             	inc    %rax
    1e2c:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if ((temp & 0xc0) != 0x80)
    1e30:	89 d0                	mov    %edx,%eax
    1e32:	25 c0 00 00 00       	and    $0xc0,%eax
    1e37:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1e3a:	0f 85 bb 02 00 00    	jne    20fb <mxml_fd_getc+0x492>
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
    1e40:	83 e3 0f             	and    $0xf,%ebx
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1e43:	41 83 e4 3f          	and    $0x3f,%r12d
    1e47:	83 e2 3f             	and    $0x3f,%edx
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
    1e4a:	c1 e3 06             	shl    $0x6,%ebx
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1e4d:	44 09 e3             	or     %r12d,%ebx
    1e50:	c1 e3 06             	shl    $0x6,%ebx
    1e53:	09 d3                	or     %edx,%ebx

	  if (ch < 0x800)
    1e55:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
    1e5b:	0f 8e f0 00 00 00    	jle    1f51 <mxml_fd_getc+0x2e8>

         /*
	  * Ignore (strip) Byte Order Mark (BOM)...
	  */

	  if (ch == 0xfeff)
    1e61:	81 fb ff fe 00 00    	cmp    $0xfeff,%ebx
    1e67:	0f 84 0c fe ff ff    	je     1c79 <mxml_fd_getc+0x10>
    1e6d:	e9 8c 02 00 00       	jmpq   20fe <mxml_fd_getc+0x495>
	    return (mxml_fd_getc(p, encoding));
	}
	else if ((ch & 0xf8) == 0xf0)
    1e72:	89 d8                	mov    %ebx,%eax
    1e74:	25 f8 00 00 00       	and    $0xf8,%eax
    1e79:	3d f0 00 00 00       	cmp    $0xf0,%eax
    1e7e:	0f 85 77 02 00 00    	jne    20fb <mxml_fd_getc+0x492>
	{
	 /*
	  * Four-byte value...
	  */

	  if (buf->current >= buf->end)
    1e84:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1e88:	72 10                	jb     1e9a <mxml_fd_getc+0x231>
	    if (mxml_fd_read(buf) < 0)
    1e8a:	48 89 ef             	mov    %rbp,%rdi
    1e8d:	e8 82 fd ff ff       	callq  1c14 <mxml_fd_read>
    1e92:	85 c0                	test   %eax,%eax
    1e94:	0f 88 61 02 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    1e9a:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1e9e:	44 0f b6 28          	movzbl (%rax),%r13d
    1ea2:	48 8d 50 01          	lea    0x1(%rax),%rdx
    1ea6:	48 89 55 08          	mov    %rdx,0x8(%rbp)

	  if ((temp & 0xc0) != 0x80)
    1eaa:	44 89 e8             	mov    %r13d,%eax
    1ead:	25 c0 00 00 00       	and    $0xc0,%eax
    1eb2:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1eb5:	0f 85 40 02 00 00    	jne    20fb <mxml_fd_getc+0x492>
	    return (EOF);

	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);

	  if (buf->current >= buf->end)
    1ebb:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1ebf:	72 10                	jb     1ed1 <mxml_fd_getc+0x268>
	    if (mxml_fd_read(buf) < 0)
    1ec1:	48 89 ef             	mov    %rbp,%rdi
    1ec4:	e8 4b fd ff ff       	callq  1c14 <mxml_fd_read>
    1ec9:	85 c0                	test   %eax,%eax
    1ecb:	0f 88 2a 02 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    1ed1:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1ed5:	44 0f b6 20          	movzbl (%rax),%r12d
    1ed9:	48 8d 50 01          	lea    0x1(%rax),%rdx
    1edd:	48 89 55 08          	mov    %rdx,0x8(%rbp)

	  if ((temp & 0xc0) != 0x80)
    1ee1:	44 89 e0             	mov    %r12d,%eax
    1ee4:	25 c0 00 00 00       	and    $0xc0,%eax
    1ee9:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1eec:	0f 85 09 02 00 00    	jne    20fb <mxml_fd_getc+0x492>
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);

	  if (buf->current >= buf->end)
    1ef2:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1ef6:	72 10                	jb     1f08 <mxml_fd_getc+0x29f>
	    if (mxml_fd_read(buf) < 0)
    1ef8:	48 89 ef             	mov    %rbp,%rdi
    1efb:	e8 14 fd ff ff       	callq  1c14 <mxml_fd_read>
    1f00:	85 c0                	test   %eax,%eax
    1f02:	0f 88 f3 01 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    1f08:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1f0c:	0f b6 10             	movzbl (%rax),%edx
    1f0f:	48 ff c0             	inc    %rax
    1f12:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if ((temp & 0xc0) != 0x80)
    1f16:	89 d0                	mov    %edx,%eax
    1f18:	25 c0 00 00 00       	and    $0xc0,%eax
    1f1d:	83 c0 80             	add    $0xffffffffffffff80,%eax
    1f20:	0f 85 d5 01 00 00    	jne    20fb <mxml_fd_getc+0x492>
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
    1f26:	83 e3 07             	and    $0x7,%ebx
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1f29:	41 83 e5 3f          	and    $0x3f,%r13d
    1f2d:	41 83 e4 3f          	and    $0x3f,%r12d
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
    1f31:	c1 e3 06             	shl    $0x6,%ebx
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1f34:	83 e2 3f             	and    $0x3f,%edx
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1f37:	44 09 eb             	or     %r13d,%ebx
    1f3a:	c1 e3 06             	shl    $0x6,%ebx
    1f3d:	44 09 e3             	or     %r12d,%ebx
	  temp = *(buf->current)++;

	  if ((temp & 0xc0) != 0x80)
	    return (EOF);

	  ch = (ch << 6) | (temp & 0x3f);
    1f40:	c1 e3 06             	shl    $0x6,%ebx
    1f43:	09 d3                	or     %edx,%ebx

	  if (ch < 0x10000)
    1f45:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    1f4b:	0f 8f ad 01 00 00    	jg     20fe <mxml_fd_getc+0x495>
	  {
	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
    1f51:	89 de                	mov    %ebx,%esi
    1f53:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 1f5a <mxml_fd_getc+0x2f1>
    1f5a:	e9 17 01 00 00       	jmpq   2076 <mxml_fd_getc+0x40d>
    case ENCODE_UTF16BE :
       /*
        * Read UTF-16 big-endian char...
	*/

	if (buf->current >= buf->end)
    1f5f:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    1f63:	72 10                	jb     1f75 <mxml_fd_getc+0x30c>
	  if (mxml_fd_read(buf) < 0)
    1f65:	48 89 ef             	mov    %rbp,%rdi
    1f68:	e8 a7 fc ff ff       	callq  1c14 <mxml_fd_read>
    1f6d:	85 c0                	test   %eax,%eax
    1f6f:	0f 88 86 01 00 00    	js     20fb <mxml_fd_getc+0x492>
	    return (EOF);

	temp = *(buf->current)++;
    1f75:	48 8b 45 08          	mov    0x8(%rbp),%rax

	ch = (ch << 8) | temp;
    1f79:	c1 e3 08             	shl    $0x8,%ebx

	if (buf->current >= buf->end)
	  if (mxml_fd_read(buf) < 0)
	    return (EOF);

	temp = *(buf->current)++;
    1f7c:	0f b6 10             	movzbl (%rax),%edx
    1f7f:	48 8d 48 01          	lea    0x1(%rax),%rcx
    1f83:	48 89 4d 08          	mov    %rcx,0x8(%rbp)

	ch = (ch << 8) | temp;
    1f87:	09 d3                	or     %edx,%ebx

	if (mxml_bad_char(ch))
    1f89:	83 fb 1f             	cmp    $0x1f,%ebx
    1f8c:	7f 13                	jg     1fa1 <mxml_fd_getc+0x338>
    1f8e:	83 fb 0a             	cmp    $0xa,%ebx
    1f91:	74 0e                	je     1fa1 <mxml_fd_getc+0x338>
    1f93:	83 fb 0d             	cmp    $0xd,%ebx
    1f96:	74 09                	je     1fa1 <mxml_fd_getc+0x338>
    1f98:	83 fb 09             	cmp    $0x9,%ebx
    1f9b:	0f 85 cc 00 00 00    	jne    206d <mxml_fd_getc+0x404>
	{
	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
        	     ch);
	  return (EOF);
	}
        else if (ch >= 0xd800 && ch <= 0xdbff)
    1fa1:	8d 83 00 28 ff ff    	lea    -0xd800(%rbx),%eax
    1fa7:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    1fac:	0f 87 4c 01 00 00    	ja     20fe <mxml_fd_getc+0x495>
	  * Multi-word UTF-16 char...
	  */

          int lch;

	  if (buf->current >= buf->end)
    1fb2:	48 3b 4d 10          	cmp    0x10(%rbp),%rcx
    1fb6:	72 10                	jb     1fc8 <mxml_fd_getc+0x35f>
	    if (mxml_fd_read(buf) < 0)
    1fb8:	48 89 ef             	mov    %rbp,%rdi
    1fbb:	e8 54 fc ff ff       	callq  1c14 <mxml_fd_read>
    1fc0:	85 c0                	test   %eax,%eax
    1fc2:	0f 88 33 01 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  lch = *(buf->current)++;
    1fc8:	48 8b 45 08          	mov    0x8(%rbp),%rax
    1fcc:	44 8a 20             	mov    (%rax),%r12b
    1fcf:	48 ff c0             	inc    %rax

	  if (buf->current >= buf->end)
    1fd2:	48 3b 45 10          	cmp    0x10(%rbp),%rax

	  if (buf->current >= buf->end)
	    if (mxml_fd_read(buf) < 0)
	      return (EOF);

	  lch = *(buf->current)++;
    1fd6:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if (buf->current >= buf->end)
    1fda:	72 10                	jb     1fec <mxml_fd_getc+0x383>
	    if (mxml_fd_read(buf) < 0)
    1fdc:	48 89 ef             	mov    %rbp,%rdi
    1fdf:	e8 30 fc ff ff       	callq  1c14 <mxml_fd_read>
    1fe4:	85 c0                	test   %eax,%eax
    1fe6:	0f 88 0f 01 00 00    	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    1fec:	48 8b 45 08          	mov    0x8(%rbp),%rax

	  lch = (lch << 8) | temp;
    1ff0:	41 0f b6 cc          	movzbl %r12b,%ecx
    1ff4:	c1 e1 08             	shl    $0x8,%ecx

	  if (buf->current >= buf->end)
	    if (mxml_fd_read(buf) < 0)
	      return (EOF);

	  temp = *(buf->current)++;
    1ff7:	0f b6 10             	movzbl (%rax),%edx
    1ffa:	48 ff c0             	inc    %rax
    1ffd:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  lch = (lch << 8) | temp;
    2001:	09 d1                	or     %edx,%ecx

          if (lch < 0xdc00 || lch >= 0xdfff)
    2003:	8d 81 00 24 ff ff    	lea    -0xdc00(%rcx),%eax
    2009:	3d fe 03 00 00       	cmp    $0x3fe,%eax
    200e:	0f 87 e7 00 00 00    	ja     20fb <mxml_fd_getc+0x492>
	    return (EOF);

          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
    2014:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
    201a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    2020:	c1 e3 0a             	shl    $0xa,%ebx
    2023:	09 d9                	or     %ebx,%ecx
    2025:	8d 99 00 00 01 00    	lea    0x10000(%rcx),%ebx
    202b:	e9 ce 00 00 00       	jmpq   20fe <mxml_fd_getc+0x495>
    case ENCODE_UTF16LE :
       /*
        * Read UTF-16 little-endian char...
	*/

	if (buf->current >= buf->end)
    2030:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    2034:	72 10                	jb     2046 <mxml_fd_getc+0x3dd>
	  if (mxml_fd_read(buf) < 0)
    2036:	48 89 ef             	mov    %rbp,%rdi
    2039:	e8 d6 fb ff ff       	callq  1c14 <mxml_fd_read>
    203e:	85 c0                	test   %eax,%eax
    2040:	0f 88 b5 00 00 00    	js     20fb <mxml_fd_getc+0x492>
	    return (EOF);

	temp = *(buf->current)++;
    2046:	48 8b 55 08          	mov    0x8(%rbp),%rdx
    204a:	0f b6 02             	movzbl (%rdx),%eax
    204d:	48 ff c2             	inc    %rdx
    2050:	48 89 55 08          	mov    %rdx,0x8(%rbp)

	ch |= (temp << 8);
    2054:	c1 e0 08             	shl    $0x8,%eax
    2057:	09 c3                	or     %eax,%ebx

        if (mxml_bad_char(ch))
    2059:	83 fb 1f             	cmp    $0x1f,%ebx
    205c:	7f 21                	jg     207f <mxml_fd_getc+0x416>
    205e:	83 fb 0a             	cmp    $0xa,%ebx
    2061:	74 1c                	je     207f <mxml_fd_getc+0x416>
    2063:	83 fb 0d             	cmp    $0xd,%ebx
    2066:	74 17                	je     207f <mxml_fd_getc+0x416>
    2068:	83 fb 09             	cmp    $0x9,%ebx
    206b:	74 12                	je     207f <mxml_fd_getc+0x416>
	{
	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
    206d:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 2074 <mxml_fd_getc+0x40b>
    2074:	89 de                	mov    %ebx,%esi
    2076:	31 c0                	xor    %eax,%eax
    2078:	e8 00 00 00 00       	callq  207d <mxml_fd_getc+0x414>
    207d:	eb 7c                	jmp    20fb <mxml_fd_getc+0x492>
        	     ch);
	  return (EOF);
	}
        else if (ch >= 0xd800 && ch <= 0xdbff)
    207f:	8d 83 00 28 ff ff    	lea    -0xd800(%rbx),%eax
    2085:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    208a:	77 72                	ja     20fe <mxml_fd_getc+0x495>
	  * Multi-word UTF-16 char...
	  */

          int lch;

	  if (buf->current >= buf->end)
    208c:	48 3b 55 10          	cmp    0x10(%rbp),%rdx
    2090:	72 0c                	jb     209e <mxml_fd_getc+0x435>
	    if (mxml_fd_read(buf) < 0)
    2092:	48 89 ef             	mov    %rbp,%rdi
    2095:	e8 7a fb ff ff       	callq  1c14 <mxml_fd_read>
    209a:	85 c0                	test   %eax,%eax
    209c:	78 5d                	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  lch = *(buf->current)++;
    209e:	48 8b 45 08          	mov    0x8(%rbp),%rax
    20a2:	44 8a 20             	mov    (%rax),%r12b
    20a5:	48 ff c0             	inc    %rax

	  if (buf->current >= buf->end)
    20a8:	48 3b 45 10          	cmp    0x10(%rbp),%rax

	  if (buf->current >= buf->end)
	    if (mxml_fd_read(buf) < 0)
	      return (EOF);

	  lch = *(buf->current)++;
    20ac:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if (buf->current >= buf->end)
    20b0:	72 0c                	jb     20be <mxml_fd_getc+0x455>
	    if (mxml_fd_read(buf) < 0)
    20b2:	48 89 ef             	mov    %rbp,%rdi
    20b5:	e8 5a fb ff ff       	callq  1c14 <mxml_fd_read>
    20ba:	85 c0                	test   %eax,%eax
    20bc:	78 3d                	js     20fb <mxml_fd_getc+0x492>
	      return (EOF);

	  temp = *(buf->current)++;
    20be:	48 8b 45 08          	mov    0x8(%rbp),%rax
    20c2:	0f b6 10             	movzbl (%rax),%edx
    20c5:	48 ff c0             	inc    %rax
    20c8:	48 89 45 08          	mov    %rax,0x8(%rbp)

	  if (buf->current >= buf->end)
	    if (mxml_fd_read(buf) < 0)
	      return (EOF);

	  lch = *(buf->current)++;
    20cc:	41 0f b6 c4          	movzbl %r12b,%eax
	    if (mxml_fd_read(buf) < 0)
	      return (EOF);

	  temp = *(buf->current)++;

	  lch |= (temp << 8);
    20d0:	c1 e2 08             	shl    $0x8,%edx
    20d3:	09 c2                	or     %eax,%edx

          if (lch < 0xdc00 || lch >= 0xdfff)
    20d5:	8d 82 00 24 ff ff    	lea    -0xdc00(%rdx),%eax
    20db:	3d fe 03 00 00       	cmp    $0x3fe,%eax
    20e0:	77 19                	ja     20fb <mxml_fd_getc+0x492>
	    return (EOF);

          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
    20e2:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
    20e8:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    20ee:	c1 e3 0a             	shl    $0xa,%ebx
    20f1:	09 da                	or     %ebx,%edx
    20f3:	8d 9a 00 00 01 00    	lea    0x10000(%rdx),%ebx
    20f9:	eb 03                	jmp    20fe <mxml_fd_getc+0x495>
    20fb:	83 cb ff             	or     $0xffffffffffffffff,%ebx
#if DEBUG > 1
  printf("mxml_fd_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
#endif /* DEBUG > 1 */

  return (ch);
}
    20fe:	5d                   	pop    %rbp
    20ff:	89 d8                	mov    %ebx,%eax
    2101:	5b                   	pop    %rbx
    2102:	5d                   	pop    %rbp
    2103:	41 5c                	pop    %r12
    2105:	41 5d                	pop    %r13
    2107:	c3                   	retq   

0000000000002108 <mxml_write_name>:
static int				/* O - 0 on success, -1 on failure */
mxml_write_name(const char *s,		/* I - Name to write */
                void       *p,		/* I - Write pointer */
		int        (*putc_cb)(int, void *))
					/* I - Write callback */
{
    2108:	41 56                	push   %r14
    210a:	41 55                	push   %r13
    210c:	41 54                	push   %r12
    210e:	49 89 d4             	mov    %rdx,%r12
    2111:	55                   	push   %rbp
    2112:	48 89 f5             	mov    %rsi,%rbp
    2115:	53                   	push   %rbx
  char		quote;			/* Quote character */
  const char	*name;			/* Entity name */


  if (*s == '\"' || *s == '\'')
    2116:	8a 07                	mov    (%rdi),%al
static int				/* O - 0 on success, -1 on failure */
mxml_write_name(const char *s,		/* I - Name to write */
                void       *p,		/* I - Write pointer */
		int        (*putc_cb)(int, void *))
					/* I - Write callback */
{
    2118:	48 89 fb             	mov    %rdi,%rbx
  char		quote;			/* Quote character */
  const char	*name;			/* Entity name */


  if (*s == '\"' || *s == '\'')
    211b:	3c 22                	cmp    $0x22,%al
    211d:	74 08                	je     2127 <mxml_write_name+0x1f>
    211f:	3c 27                	cmp    $0x27,%al
    2121:	0f 85 9a 00 00 00    	jne    21c1 <mxml_write_name+0xb9>
  {
   /*
    * Write a quoted name string...
    */

    if ((*putc_cb)(*s, p) < 0)
    2127:	0f be f8             	movsbl %al,%edi
    212a:	48 89 ee             	mov    %rbp,%rsi
    212d:	41 ff d4             	callq  *%r12
    2130:	85 c0                	test   %eax,%eax
    2132:	0f 88 91 00 00 00    	js     21c9 <mxml_write_name+0xc1>
      return (-1);

    quote = *s++;
    2138:	44 8a 33             	mov    (%rbx),%r14b
    213b:	4c 8d 6b 01          	lea    0x1(%rbx),%r13
    213f:	eb 53                	jmp    2194 <mxml_write_name+0x8c>

    while (*s && *s != quote)
    {
      if ((name = mxmlEntityGetName(*s)) != NULL)
    2141:	0f be f8             	movsbl %al,%edi
    2144:	e8 00 00 00 00       	callq  2149 <mxml_write_name+0x41>
    2149:	48 85 c0             	test   %rax,%rax
    214c:	48 89 c3             	mov    %rax,%rbx
    214f:	74 31                	je     2182 <mxml_write_name+0x7a>
      {
	if ((*putc_cb)('&', p) < 0)
    2151:	48 89 ee             	mov    %rbp,%rsi
    2154:	bf 26 00 00 00       	mov    $0x26,%edi
    2159:	41 ff d4             	callq  *%r12
    215c:	85 c0                	test   %eax,%eax
    215e:	79 12                	jns    2172 <mxml_write_name+0x6a>
    2160:	eb 67                	jmp    21c9 <mxml_write_name+0xc1>
          return (-1);

        while (*name)
	{
	  if ((*putc_cb)(*name, p) < 0)
    2162:	0f be f8             	movsbl %al,%edi
    2165:	48 89 ee             	mov    %rbp,%rsi
    2168:	41 ff d4             	callq  *%r12
    216b:	85 c0                	test   %eax,%eax
    216d:	78 5a                	js     21c9 <mxml_write_name+0xc1>
            return (-1);

          name ++;
    216f:	48 ff c3             	inc    %rbx
      if ((name = mxmlEntityGetName(*s)) != NULL)
      {
	if ((*putc_cb)('&', p) < 0)
          return (-1);

        while (*name)
    2172:	8a 03                	mov    (%rbx),%al
    2174:	84 c0                	test   %al,%al
    2176:	75 ea                	jne    2162 <mxml_write_name+0x5a>
            return (-1);

          name ++;
	}

	if ((*putc_cb)(';', p) < 0)
    2178:	48 89 ee             	mov    %rbp,%rsi
    217b:	bf 3b 00 00 00       	mov    $0x3b,%edi
    2180:	eb 08                	jmp    218a <mxml_write_name+0x82>
          return (-1);
      }
      else if ((*putc_cb)(*s, p) < 0)
    2182:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
    2187:	48 89 ee             	mov    %rbp,%rsi
    218a:	41 ff d4             	callq  *%r12
    218d:	85 c0                	test   %eax,%eax
    218f:	78 38                	js     21c9 <mxml_write_name+0xc1>
	return (-1);

      s ++;
    2191:	49 ff c5             	inc    %r13
    if ((*putc_cb)(*s, p) < 0)
      return (-1);

    quote = *s++;

    while (*s && *s != quote)
    2194:	41 8a 45 00          	mov    0x0(%r13),%al
    2198:	84 c0                	test   %al,%al
    219a:	74 05                	je     21a1 <mxml_write_name+0x99>
    219c:	44 38 f0             	cmp    %r14b,%al
    219f:	75 a0                	jne    2141 <mxml_write_name+0x39>

   /*
    * Write the end quote...
    */

    if ((*putc_cb)(quote, p) < 0)
    21a1:	41 0f be fe          	movsbl %r14b,%edi
    21a5:	48 89 ee             	mov    %rbp,%rsi
    21a8:	41 ff d4             	callq  *%r12
    21ab:	85 c0                	test   %eax,%eax
    21ad:	79 1f                	jns    21ce <mxml_write_name+0xc6>
    21af:	eb 18                	jmp    21c9 <mxml_write_name+0xc1>
    * Write a non-quoted name string...
    */

    while (*s)
    {
      if ((*putc_cb)(*s, p) < 0)
    21b1:	0f be f8             	movsbl %al,%edi
    21b4:	48 89 ee             	mov    %rbp,%rsi
    21b7:	41 ff d4             	callq  *%r12
    21ba:	85 c0                	test   %eax,%eax
    21bc:	78 0b                	js     21c9 <mxml_write_name+0xc1>
	return (-1);

      s ++;
    21be:	48 ff c3             	inc    %rbx
  {
   /*
    * Write a non-quoted name string...
    */

    while (*s)
    21c1:	8a 03                	mov    (%rbx),%al
    21c3:	84 c0                	test   %al,%al
    21c5:	75 ea                	jne    21b1 <mxml_write_name+0xa9>
    21c7:	eb 05                	jmp    21ce <mxml_write_name+0xc6>
    21c9:	83 c8 ff             	or     $0xffffffffffffffff,%eax
    21cc:	eb 02                	jmp    21d0 <mxml_write_name+0xc8>
    21ce:	31 c0                	xor    %eax,%eax
      s ++;
    }
  }

  return (0);
}
    21d0:	5b                   	pop    %rbx
    21d1:	5d                   	pop    %rbp
    21d2:	41 5c                	pop    %r12
    21d4:	41 5d                	pop    %r13
    21d6:	41 5e                	pop    %r14
    21d8:	c3                   	retq   

00000000000021d9 <mxml_write_string>:
static int				/* O - 0 on success, -1 on failure */
mxml_write_string(
    const char      *s,			/* I - String to write */
    void            *p,			/* I - Write pointer */
    _mxml_putc_cb_t putc_cb)		/* I - Write callback */
{
    21d9:	41 55                	push   %r13
    21db:	49 89 fd             	mov    %rdi,%r13
    21de:	41 54                	push   %r12
    21e0:	49 89 f4             	mov    %rsi,%r12
    21e3:	55                   	push   %rbp
    21e4:	48 89 d5             	mov    %rdx,%rbp
    21e7:	53                   	push   %rbx
    21e8:	48 83 ec 08          	sub    $0x8,%rsp
    21ec:	eb 50                	jmp    223e <mxml_write_string+0x65>
  const char	*name;			/* Entity name, if any */


  while (*s)
  {
    if ((name = mxmlEntityGetName(*s)) != NULL)
    21ee:	0f be f8             	movsbl %al,%edi
    21f1:	e8 00 00 00 00       	callq  21f6 <mxml_write_string+0x1d>
    21f6:	48 85 c0             	test   %rax,%rax
    21f9:	48 89 c3             	mov    %rax,%rbx
    21fc:	74 2f                	je     222d <mxml_write_string+0x54>
    {
      if ((*putc_cb)('&', p) < 0)
    21fe:	4c 89 e6             	mov    %r12,%rsi
    2201:	bf 26 00 00 00       	mov    $0x26,%edi
    2206:	ff d5                	callq  *%rbp
    2208:	85 c0                	test   %eax,%eax
    220a:	79 11                	jns    221d <mxml_write_string+0x44>
    220c:	eb 3c                	jmp    224a <mxml_write_string+0x71>
        return (-1);

      while (*name)
      {
	if ((*putc_cb)(*name, p) < 0)
    220e:	0f be f8             	movsbl %al,%edi
    2211:	4c 89 e6             	mov    %r12,%rsi
    2214:	ff d5                	callq  *%rbp
    2216:	85 c0                	test   %eax,%eax
    2218:	78 30                	js     224a <mxml_write_string+0x71>
          return (-1);
        name ++;
    221a:	48 ff c3             	inc    %rbx
    if ((name = mxmlEntityGetName(*s)) != NULL)
    {
      if ((*putc_cb)('&', p) < 0)
        return (-1);

      while (*name)
    221d:	8a 03                	mov    (%rbx),%al
    221f:	84 c0                	test   %al,%al
    2221:	75 eb                	jne    220e <mxml_write_string+0x35>
	if ((*putc_cb)(*name, p) < 0)
          return (-1);
        name ++;
      }

      if ((*putc_cb)(';', p) < 0)
    2223:	4c 89 e6             	mov    %r12,%rsi
    2226:	bf 3b 00 00 00       	mov    $0x3b,%edi
    222b:	eb 08                	jmp    2235 <mxml_write_string+0x5c>
        return (-1);
    }
    else if ((*putc_cb)(*s, p) < 0)
    222d:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
    2232:	4c 89 e6             	mov    %r12,%rsi
    2235:	ff d5                	callq  *%rbp
    2237:	85 c0                	test   %eax,%eax
    2239:	78 0f                	js     224a <mxml_write_string+0x71>
      return (-1);

    s ++;
    223b:	49 ff c5             	inc    %r13
    _mxml_putc_cb_t putc_cb)		/* I - Write callback */
{
  const char	*name;			/* Entity name, if any */


  while (*s)
    223e:	41 8a 45 00          	mov    0x0(%r13),%al
    2242:	84 c0                	test   %al,%al
    2244:	75 a8                	jne    21ee <mxml_write_string+0x15>
    2246:	31 c0                	xor    %eax,%eax
    2248:	eb 03                	jmp    224d <mxml_write_string+0x74>
    224a:	83 c8 ff             	or     $0xffffffffffffffff,%eax

    s ++;
  }

  return (0);
}
    224d:	41 5c                	pop    %r12
    224f:	5b                   	pop    %rbx
    2250:	5d                   	pop    %rbp
    2251:	41 5c                	pop    %r12
    2253:	41 5d                	pop    %r13
    2255:	c3                   	retq   

0000000000002256 <mxml_write_node>:
                void            *p,	/* I - File to write to */
	        mxml_save_cb_t  cb,	/* I - Whitespace callback */
		int             col,	/* I - Current column */
		_mxml_putc_cb_t putc_cb,/* I - Output callback */
		_mxml_global_t  *global)/* I - Global data */
{
    2256:	41 57                	push   %r15
    2258:	41 56                	push   %r14
    225a:	49 89 fe             	mov    %rdi,%r14
    225d:	41 55                	push   %r13
    225f:	49 89 f5             	mov    %rsi,%r13
    2262:	41 54                	push   %r12
    2264:	4d 89 c4             	mov    %r8,%r12
    2267:	55                   	push   %rbp
    2268:	53                   	push   %rbx
    2269:	89 cb                	mov    %ecx,%ebx
    226b:	48 81 ec 58 01 00 00 	sub    $0x158,%rsp

 /*
  * Print the node value...
  */

  switch (node->type)
    2272:	83 3f 05             	cmpl   $0x5,(%rdi)
                void            *p,	/* I - File to write to */
	        mxml_save_cb_t  cb,	/* I - Whitespace callback */
		int             col,	/* I - Current column */
		_mxml_putc_cb_t putc_cb,/* I - Output callback */
		_mxml_global_t  *global)/* I - Global data */
{
    2275:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
    227a:	4c 89 4c 24 38       	mov    %r9,0x38(%rsp)

 /*
  * Print the node value...
  */

  switch (node->type)
    227f:	0f 87 30 05 00 00    	ja     27b5 <mxml_write_node+0x55f>
    2285:	8b 07                	mov    (%rdi),%eax
    2287:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 228e <mxml_write_node+0x38>
    228e:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    2292:	48 01 d0             	add    %rdx,%rax
    2295:	ff e0                	jmpq   *%rax
  {
    case MXML_ELEMENT :
	col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_OPEN, col, putc_cb);
    2297:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    229c:	4d 89 c1             	mov    %r8,%r9
    229f:	41 89 c8             	mov    %ecx,%r8d
    22a2:	31 c9                	xor    %ecx,%ecx
    22a4:	e8 69 dd ff ff       	callq  12 <mxml_write_ws>

	if ((*putc_cb)('<', p) < 0)
    22a9:	4c 89 ee             	mov    %r13,%rsi
  */

  switch (node->type)
  {
    case MXML_ELEMENT :
	col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_OPEN, col, putc_cb);
    22ac:	89 c5                	mov    %eax,%ebp

	if ((*putc_cb)('<', p) < 0)
    22ae:	bf 3c 00 00 00       	mov    $0x3c,%edi
    22b3:	41 ff d4             	callq  *%r12
    22b6:	85 c0                	test   %eax,%eax
    22b8:	0f 88 f7 04 00 00    	js     27b5 <mxml_write_node+0x55f>
	  return (-1);
	if (node->value.element.name[0] == '?' ||
    22be:	49 8b 5e 30          	mov    0x30(%r14),%rbx
    22c2:	80 3b 3f             	cmpb   $0x3f,(%rbx)
    22c5:	74 46                	je     230d <mxml_write_node+0xb7>
    22c7:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # 22ce <mxml_write_node+0x78>
    22ce:	ba 03 00 00 00       	mov    $0x3,%edx
    22d3:	48 89 df             	mov    %rbx,%rdi
    22d6:	e8 00 00 00 00       	callq  22db <mxml_write_node+0x85>
    22db:	85 c0                	test   %eax,%eax
    22dd:	74 2e                	je     230d <mxml_write_node+0xb7>
    22df:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # 22e6 <mxml_write_node+0x90>
    22e6:	ba 08 00 00 00       	mov    $0x8,%edx
    22eb:	48 89 df             	mov    %rbx,%rdi
    22ee:	e8 00 00 00 00       	callq  22f3 <mxml_write_node+0x9d>
    22f3:	85 c0                	test   %eax,%eax
    22f5:	74 16                	je     230d <mxml_write_node+0xb7>
    22f7:	eb 1c                	jmp    2315 <mxml_write_node+0xbf>

	  const char	*ptr;		/* Pointer into name */


	  for (ptr = node->value.element.name; *ptr; ptr ++)
	    if ((*putc_cb)(*ptr, p) < 0)
    22f9:	0f be f8             	movsbl %al,%edi
    22fc:	4c 89 ee             	mov    %r13,%rsi
    22ff:	41 ff d4             	callq  *%r12
    2302:	85 c0                	test   %eax,%eax
    2304:	0f 88 ab 04 00 00    	js     27b5 <mxml_write_node+0x55f>
	  */

	  const char	*ptr;		/* Pointer into name */


	  for (ptr = node->value.element.name; *ptr; ptr ++)
    230a:	48 ff c3             	inc    %rbx
    230d:	8a 03                	mov    (%rbx),%al
    230f:	84 c0                	test   %al,%al
    2311:	75 e6                	jne    22f9 <mxml_write_node+0xa3>
    2313:	eb 16                	jmp    232b <mxml_write_node+0xd5>
	    if ((*putc_cb)(*ptr, p) < 0)
	      return (-1);
	}
	else if (mxml_write_name(node->value.element.name, p, putc_cb) < 0)
    2315:	4c 89 e2             	mov    %r12,%rdx
    2318:	4c 89 ee             	mov    %r13,%rsi
    231b:	48 89 df             	mov    %rbx,%rdi
    231e:	e8 e5 fd ff ff       	callq  2108 <mxml_write_name>
    2323:	85 c0                	test   %eax,%eax
    2325:	0f 88 8a 04 00 00    	js     27b5 <mxml_write_node+0x55f>
	  return (-1);

	col += strlen(node->value.element.name) + 1;
    232b:	49 8b 7e 30          	mov    0x30(%r14),%rdi
    232f:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    2333:	31 c0                	xor    %eax,%eax
    2335:	48 89 d1             	mov    %rdx,%rcx

	for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
    2338:	49 8b 5e 40          	mov    0x40(%r14),%rbx
	      return (-1);
	}
	else if (mxml_write_name(node->value.element.name, p, putc_cb) < 0)
	  return (-1);

	col += strlen(node->value.element.name) + 1;
    233c:	f2 ae                	repnz scas %es:(%rdi),%al

	for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
    233e:	41 8b 46 38          	mov    0x38(%r14),%eax
	      return (-1);
	}
	else if (mxml_write_name(node->value.element.name, p, putc_cb) < 0)
	  return (-1);

	col += strlen(node->value.element.name) + 1;
    2342:	f7 d1                	not    %ecx
    2344:	8d 2c 29             	lea    (%rcx,%rbp,1),%ebp

	for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
    2347:	89 44 24 4c          	mov    %eax,0x4c(%rsp)
    234b:	e9 e4 00 00 00       	jmpq   2434 <mxml_write_node+0x1de>
	     i > 0;
	     i --, attr ++)
	{
	  width = strlen(attr->name);
    2350:	48 8b 3b             	mov    (%rbx),%rdi
    2353:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    2357:	31 c0                	xor    %eax,%eax
    2359:	f2 ae                	repnz scas %es:(%rdi),%al

	  if (attr->value)
    235b:	48 8b 7b 08          	mov    0x8(%rbx),%rdi

	for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
	     i > 0;
	     i --, attr ++)
	{
	  width = strlen(attr->name);
    235f:	48 f7 d1             	not    %rcx
    2362:	44 8d 79 ff          	lea    -0x1(%rcx),%r15d

	  if (attr->value)
    2366:	48 85 ff             	test   %rdi,%rdi
    2369:	74 0e                	je     2379 <mxml_write_node+0x123>
	    width += strlen(attr->value) + 3;
    236b:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    236f:	f2 ae                	repnz scas %es:(%rdi),%al
    2371:	48 f7 d1             	not    %rcx
    2374:	45 8d 7c 0f 02       	lea    0x2(%r15,%rcx,1),%r15d

	  if (global->wrap > 0 && (col + width) > global->wrap)
    2379:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    237e:	8b 90 30 03 00 00    	mov    0x330(%rax),%edx
    2384:	85 d2                	test   %edx,%edx
    2386:	7e 1f                	jle    23a7 <mxml_write_node+0x151>
    2388:	41 8d 04 2f          	lea    (%r15,%rbp,1),%eax
    238c:	39 d0                	cmp    %edx,%eax
    238e:	7e 17                	jle    23a7 <mxml_write_node+0x151>
	  {
	    if ((*putc_cb)('\n', p) < 0)
    2390:	4c 89 ee             	mov    %r13,%rsi
    2393:	bf 0a 00 00 00       	mov    $0xa,%edi
    2398:	41 ff d4             	callq  *%r12
    239b:	85 c0                	test   %eax,%eax
    239d:	0f 88 12 04 00 00    	js     27b5 <mxml_write_node+0x55f>
    23a3:	31 ed                	xor    %ebp,%ebp
    23a5:	eb 15                	jmp    23bc <mxml_write_node+0x166>

	    col = 0;
	  }
	  else
	  {
	    if ((*putc_cb)(' ', p) < 0)
    23a7:	4c 89 ee             	mov    %r13,%rsi
    23aa:	bf 20 00 00 00       	mov    $0x20,%edi
    23af:	41 ff d4             	callq  *%r12
    23b2:	85 c0                	test   %eax,%eax
    23b4:	0f 88 fb 03 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);

	    col ++;
    23ba:	ff c5                	inc    %ebp
	  }

	  if (mxml_write_name(attr->name, p, putc_cb) < 0)
    23bc:	48 8b 3b             	mov    (%rbx),%rdi
    23bf:	4c 89 e2             	mov    %r12,%rdx
    23c2:	4c 89 ee             	mov    %r13,%rsi
    23c5:	e8 3e fd ff ff       	callq  2108 <mxml_write_name>
    23ca:	85 c0                	test   %eax,%eax
    23cc:	0f 88 e3 03 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);

	  if (attr->value)
    23d2:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
    23d7:	74 50                	je     2429 <mxml_write_node+0x1d3>
	  {
	    if ((*putc_cb)('=', p) < 0)
    23d9:	4c 89 ee             	mov    %r13,%rsi
    23dc:	bf 3d 00 00 00       	mov    $0x3d,%edi
    23e1:	41 ff d4             	callq  *%r12
    23e4:	85 c0                	test   %eax,%eax
    23e6:	0f 88 c9 03 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);
	    if ((*putc_cb)('\"', p) < 0)
    23ec:	4c 89 ee             	mov    %r13,%rsi
    23ef:	bf 22 00 00 00       	mov    $0x22,%edi
    23f4:	41 ff d4             	callq  *%r12
    23f7:	85 c0                	test   %eax,%eax
    23f9:	0f 88 b6 03 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);
	    if (mxml_write_string(attr->value, p, putc_cb) < 0)
    23ff:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    2403:	4c 89 e2             	mov    %r12,%rdx
    2406:	4c 89 ee             	mov    %r13,%rsi
    2409:	e8 cb fd ff ff       	callq  21d9 <mxml_write_string>
    240e:	85 c0                	test   %eax,%eax
    2410:	0f 88 9f 03 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);
	    if ((*putc_cb)('\"', p) < 0)
    2416:	4c 89 ee             	mov    %r13,%rsi
    2419:	bf 22 00 00 00       	mov    $0x22,%edi
    241e:	41 ff d4             	callq  *%r12
    2421:	85 c0                	test   %eax,%eax
    2423:	0f 88 8c 03 00 00    	js     27b5 <mxml_write_node+0x55f>

	col += strlen(node->value.element.name) + 1;

	for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
	     i > 0;
	     i --, attr ++)
    2429:	ff 4c 24 4c          	decl   0x4c(%rsp)
	      return (-1);
	    if ((*putc_cb)('\"', p) < 0)
	      return (-1);
	  }

	  col += width;
    242d:	44 01 fd             	add    %r15d,%ebp

	col += strlen(node->value.element.name) + 1;

	for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
	     i > 0;
	     i --, attr ++)
    2430:	48 83 c3 10          	add    $0x10,%rbx
	  return (-1);

	col += strlen(node->value.element.name) + 1;

	for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
	     i > 0;
    2434:	83 7c 24 4c 00       	cmpl   $0x0,0x4c(%rsp)
    2439:	0f 8f 11 ff ff ff    	jg     2350 <mxml_write_node+0xfa>
	  }

	  col += width;
	}

	if (node->child)
    243f:	49 83 7e 20 00       	cmpq   $0x0,0x20(%r14)
    2444:	0f 84 05 01 00 00    	je     254f <mxml_write_node+0x2f9>
	  */

	  mxml_node_t *child;		/* Current child */


	  if ((*putc_cb)('>', p) < 0)
    244a:	4c 89 ee             	mov    %r13,%rsi
    244d:	bf 3e 00 00 00       	mov    $0x3e,%edi
    2452:	41 ff d4             	callq  *%r12
    2455:	85 c0                	test   %eax,%eax
    2457:	0f 88 58 03 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);
	  else
	    col ++;

	  col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
    245d:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    2462:	44 8d 45 01          	lea    0x1(%rbp),%r8d
    2466:	4d 89 e1             	mov    %r12,%r9
    2469:	b9 01 00 00 00       	mov    $0x1,%ecx
    246e:	4c 89 ee             	mov    %r13,%rsi
    2471:	4c 89 f7             	mov    %r14,%rdi
    2474:	e8 99 db ff ff       	callq  12 <mxml_write_ws>

          for (child = node->child; child; child = child->next)
    2479:	49 8b 6e 20          	mov    0x20(%r14),%rbp
	  if ((*putc_cb)('>', p) < 0)
	    return (-1);
	  else
	    col ++;

	  col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
    247d:	89 c3                	mov    %eax,%ebx
    247f:	eb 28                	jmp    24a9 <mxml_write_node+0x253>

          for (child = node->child; child; child = child->next)
	  {
	    if ((col = mxml_write_node(child, p, cb, col, putc_cb, global)) < 0)
    2481:	4c 8b 4c 24 38       	mov    0x38(%rsp),%r9
    2486:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    248b:	89 d9                	mov    %ebx,%ecx
    248d:	4d 89 e0             	mov    %r12,%r8
    2490:	4c 89 ee             	mov    %r13,%rsi
    2493:	48 89 ef             	mov    %rbp,%rdi
    2496:	e8 bb fd ff ff       	callq  2256 <mxml_write_node>
    249b:	85 c0                	test   %eax,%eax
    249d:	89 c3                	mov    %eax,%ebx
    249f:	0f 88 10 03 00 00    	js     27b5 <mxml_write_node+0x55f>
	  else
	    col ++;

	  col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);

          for (child = node->child; child; child = child->next)
    24a5:	48 8b 6d 08          	mov    0x8(%rbp),%rbp
    24a9:	48 85 ed             	test   %rbp,%rbp
    24ac:	75 d3                	jne    2481 <mxml_write_node+0x22b>

	 /*
	  * The ? and ! elements are special-cases and have no end tags...
	  */

	  if (node->value.element.name[0] != '!' &&
    24ae:	49 8b 46 30          	mov    0x30(%r14),%rax
    24b2:	8a 00                	mov    (%rax),%al
    24b4:	3c 21                	cmp    $0x21,%al
    24b6:	0f 84 fc 02 00 00    	je     27b8 <mxml_write_node+0x562>
    24bc:	3c 3f                	cmp    $0x3f,%al
    24be:	0f 84 f4 02 00 00    	je     27b8 <mxml_write_node+0x562>
	      node->value.element.name[0] != '?')
	  {
	    col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);
    24c4:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    24c9:	41 89 d8             	mov    %ebx,%r8d
    24cc:	4d 89 e1             	mov    %r12,%r9
    24cf:	b9 02 00 00 00       	mov    $0x2,%ecx
    24d4:	4c 89 ee             	mov    %r13,%rsi
    24d7:	4c 89 f7             	mov    %r14,%rdi
    24da:	e8 33 db ff ff       	callq  12 <mxml_write_ws>

	    if ((*putc_cb)('<', p) < 0)
    24df:	4c 89 ee             	mov    %r13,%rsi
	  */

	  if (node->value.element.name[0] != '!' &&
	      node->value.element.name[0] != '?')
	  {
	    col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);
    24e2:	89 c3                	mov    %eax,%ebx

	    if ((*putc_cb)('<', p) < 0)
    24e4:	bf 3c 00 00 00       	mov    $0x3c,%edi
    24e9:	41 ff d4             	callq  *%r12
    24ec:	85 c0                	test   %eax,%eax
    24ee:	0f 88 c1 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);
	    if ((*putc_cb)('/', p) < 0)
    24f4:	4c 89 ee             	mov    %r13,%rsi
    24f7:	bf 2f 00 00 00       	mov    $0x2f,%edi
    24fc:	41 ff d4             	callq  *%r12
    24ff:	85 c0                	test   %eax,%eax
    2501:	0f 88 ae 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);
	    if (mxml_write_string(node->value.element.name, p, putc_cb) < 0)
    2507:	49 8b 7e 30          	mov    0x30(%r14),%rdi
    250b:	4c 89 e2             	mov    %r12,%rdx
    250e:	4c 89 ee             	mov    %r13,%rsi
    2511:	e8 c3 fc ff ff       	callq  21d9 <mxml_write_string>
    2516:	85 c0                	test   %eax,%eax
    2518:	0f 88 97 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);
	    if ((*putc_cb)('>', p) < 0)
    251e:	4c 89 ee             	mov    %r13,%rsi
    2521:	bf 3e 00 00 00       	mov    $0x3e,%edi
    2526:	41 ff d4             	callq  *%r12
    2529:	85 c0                	test   %eax,%eax
    252b:	0f 88 84 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	      return (-1);

	    col += strlen(node->value.element.name) + 3;
    2531:	49 8b 7e 30          	mov    0x30(%r14),%rdi
    2535:	31 c0                	xor    %eax,%eax
    2537:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx

	    col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
    253b:	4d 89 e1             	mov    %r12,%r9
	    if (mxml_write_string(node->value.element.name, p, putc_cb) < 0)
	      return (-1);
	    if ((*putc_cb)('>', p) < 0)
	      return (-1);

	    col += strlen(node->value.element.name) + 3;
    253e:	f2 ae                	repnz scas %es:(%rdi),%al
    2540:	48 f7 d1             	not    %rcx

	    col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
    2543:	44 8d 44 0b 02       	lea    0x2(%rbx,%rcx,1),%r8d
    2548:	b9 03 00 00 00       	mov    $0x3,%ecx
    254d:	eb 6f                	jmp    25be <mxml_write_node+0x368>
	  }
	}
	else if (node->value.element.name[0] == '!' ||
    254f:	49 8b 46 30          	mov    0x30(%r14),%rax
    2553:	8a 00                	mov    (%rax),%al
    2555:	3c 21                	cmp    $0x21,%al
    2557:	74 04                	je     255d <mxml_write_node+0x307>
    2559:	3c 3f                	cmp    $0x3f,%al
    255b:	75 1c                	jne    2579 <mxml_write_node+0x323>
	{
	 /*
	  * The ? and ! elements are special-cases...
	  */

	  if ((*putc_cb)('>', p) < 0)
    255d:	4c 89 ee             	mov    %r13,%rsi
    2560:	bf 3e 00 00 00       	mov    $0x3e,%edi
    2565:	41 ff d4             	callq  *%r12
    2568:	85 c0                	test   %eax,%eax
    256a:	0f 88 45 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);
	  else
	    col ++;

	  col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
    2570:	4d 89 e1             	mov    %r12,%r9
    2573:	44 8d 45 01          	lea    0x1(%rbp),%r8d
    2577:	eb 40                	jmp    25b9 <mxml_write_node+0x363>
	}
	else
	{
	  if ((*putc_cb)(' ', p) < 0)
    2579:	4c 89 ee             	mov    %r13,%rsi
    257c:	bf 20 00 00 00       	mov    $0x20,%edi
    2581:	41 ff d4             	callq  *%r12
    2584:	85 c0                	test   %eax,%eax
    2586:	0f 88 29 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);
	  if ((*putc_cb)('/', p) < 0)
    258c:	4c 89 ee             	mov    %r13,%rsi
    258f:	bf 2f 00 00 00       	mov    $0x2f,%edi
    2594:	41 ff d4             	callq  *%r12
    2597:	85 c0                	test   %eax,%eax
    2599:	0f 88 16 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);
	  if ((*putc_cb)('>', p) < 0)
    259f:	4c 89 ee             	mov    %r13,%rsi
    25a2:	bf 3e 00 00 00       	mov    $0x3e,%edi
    25a7:	41 ff d4             	callq  *%r12
    25aa:	85 c0                	test   %eax,%eax
    25ac:	0f 88 03 02 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);

	  col += 3;

	  col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
    25b2:	44 8d 45 03          	lea    0x3(%rbp),%r8d
    25b6:	4d 89 e1             	mov    %r12,%r9
    25b9:	b9 01 00 00 00       	mov    $0x1,%ecx
    25be:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    25c3:	4c 89 ee             	mov    %r13,%rsi
    25c6:	4c 89 f7             	mov    %r14,%rdi
    25c9:	e8 44 da ff ff       	callq  12 <mxml_write_ws>
    25ce:	89 c3                	mov    %eax,%ebx
    25d0:	e9 e3 01 00 00       	jmpq   27b8 <mxml_write_node+0x562>
	}
	break;

    case MXML_INTEGER :
	if (node->prev)
    25d5:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
    25da:	74 3b                	je     2617 <mxml_write_node+0x3c1>
	{
	  if (global->wrap > 0 && col > global->wrap)
    25dc:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    25e1:	8b 82 30 03 00 00    	mov    0x330(%rdx),%eax
    25e7:	85 c0                	test   %eax,%eax
    25e9:	7e 17                	jle    2602 <mxml_write_node+0x3ac>
    25eb:	39 c1                	cmp    %eax,%ecx
    25ed:	7e 13                	jle    2602 <mxml_write_node+0x3ac>
	  {
	    if ((*putc_cb)('\n', p) < 0)
    25ef:	bf 0a 00 00 00       	mov    $0xa,%edi
    25f4:	31 db                	xor    %ebx,%ebx
    25f6:	41 ff d0             	callq  *%r8
    25f9:	85 c0                	test   %eax,%eax
    25fb:	79 1a                	jns    2617 <mxml_write_node+0x3c1>
    25fd:	e9 b3 01 00 00       	jmpq   27b5 <mxml_write_node+0x55f>
	      return (-1);

	    col = 0;
	  }
	  else if ((*putc_cb)(' ', p) < 0)
    2602:	4c 89 ee             	mov    %r13,%rsi
    2605:	bf 20 00 00 00       	mov    $0x20,%edi
    260a:	41 ff d4             	callq  *%r12
    260d:	85 c0                	test   %eax,%eax
    260f:	0f 88 a0 01 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);
	  else
	    col ++;
    2615:	ff c3                	inc    %ebx
	}

	sprintf(s, "%d", node->value.integer);
    2617:	48 8d 6c 24 50       	lea    0x50(%rsp),%rbp
    261c:	41 8b 56 30          	mov    0x30(%r14),%edx
    2620:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # 2627 <mxml_write_node+0x3d1>
    2627:	31 c0                	xor    %eax,%eax
    2629:	48 89 ef             	mov    %rbp,%rdi
    262c:	e8 00 00 00 00       	callq  2631 <mxml_write_node+0x3db>
    2631:	e9 8a 00 00 00       	jmpq   26c0 <mxml_write_node+0x46a>

	col += strlen(s);
	break;

    case MXML_OPAQUE :
	if (mxml_write_string(node->value.opaque, p, putc_cb) < 0)
    2636:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
    263a:	4c 89 c2             	mov    %r8,%rdx
    263d:	e8 97 fb ff ff       	callq  21d9 <mxml_write_string>
    2642:	85 c0                	test   %eax,%eax
    2644:	0f 88 6b 01 00 00    	js     27b5 <mxml_write_node+0x55f>
	  return (-1);

	col += strlen(node->value.opaque);
    264a:	49 8b 7e 30          	mov    0x30(%r14),%rdi
    264e:	31 c0                	xor    %eax,%eax
    2650:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    2654:	f2 ae                	repnz scas %es:(%rdi),%al
    2656:	48 f7 d1             	not    %rcx
    2659:	8d 5c 0b ff          	lea    -0x1(%rbx,%rcx,1),%ebx
    265d:	e9 56 01 00 00       	jmpq   27b8 <mxml_write_node+0x562>
	break;

    case MXML_REAL :
	if (node->prev)
    2662:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
    2667:	74 3b                	je     26a4 <mxml_write_node+0x44e>
	{
	  if (global->wrap > 0 && col > global->wrap)
    2669:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    266e:	8b 82 30 03 00 00    	mov    0x330(%rdx),%eax
    2674:	85 c0                	test   %eax,%eax
    2676:	7e 17                	jle    268f <mxml_write_node+0x439>
    2678:	39 c1                	cmp    %eax,%ecx
    267a:	7e 13                	jle    268f <mxml_write_node+0x439>
	  {
	    if ((*putc_cb)('\n', p) < 0)
    267c:	bf 0a 00 00 00       	mov    $0xa,%edi
    2681:	31 db                	xor    %ebx,%ebx
    2683:	41 ff d0             	callq  *%r8
    2686:	85 c0                	test   %eax,%eax
    2688:	79 1a                	jns    26a4 <mxml_write_node+0x44e>
    268a:	e9 26 01 00 00       	jmpq   27b5 <mxml_write_node+0x55f>
	      return (-1);

	    col = 0;
	  }
	  else if ((*putc_cb)(' ', p) < 0)
    268f:	4c 89 ee             	mov    %r13,%rsi
    2692:	bf 20 00 00 00       	mov    $0x20,%edi
    2697:	41 ff d4             	callq  *%r12
    269a:	85 c0                	test   %eax,%eax
    269c:	0f 88 13 01 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);
	  else
	    col ++;
    26a2:	ff c3                	inc    %ebx
	}

	sprintf(s, "%f", node->value.real);
    26a4:	48 8d 6c 24 50       	lea    0x50(%rsp),%rbp
    26a9:	f2 41 0f 10 46 30    	movsd  0x30(%r14),%xmm0
    26af:	48 8d 35 00 00 00 00 	lea    0x0(%rip),%rsi        # 26b6 <mxml_write_node+0x460>
    26b6:	b0 01                	mov    $0x1,%al
    26b8:	48 89 ef             	mov    %rbp,%rdi
    26bb:	e8 00 00 00 00       	callq  26c0 <mxml_write_node+0x46a>
	if (mxml_write_string(s, p, putc_cb) < 0)
    26c0:	4c 89 e2             	mov    %r12,%rdx
    26c3:	4c 89 ee             	mov    %r13,%rsi
    26c6:	48 89 ef             	mov    %rbp,%rdi
    26c9:	e8 0b fb ff ff       	callq  21d9 <mxml_write_string>
    26ce:	85 c0                	test   %eax,%eax
    26d0:	0f 88 df 00 00 00    	js     27b5 <mxml_write_node+0x55f>
	  return (-1);

	col += strlen(s);
    26d6:	31 c0                	xor    %eax,%eax
    26d8:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    26dc:	48 89 ef             	mov    %rbp,%rdi
    26df:	f2 ae                	repnz scas %es:(%rdi),%al
    26e1:	e9 70 ff ff ff       	jmpq   2656 <mxml_write_node+0x400>
	break;

    case MXML_TEXT :
	if (node->value.text.whitespace && col > 0)
    26e6:	83 7f 30 00          	cmpl   $0x0,0x30(%rdi)
    26ea:	74 3f                	je     272b <mxml_write_node+0x4d5>
    26ec:	85 c9                	test   %ecx,%ecx
    26ee:	7e 3b                	jle    272b <mxml_write_node+0x4d5>
	{
	  if (global->wrap > 0 && col > global->wrap)
    26f0:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    26f5:	8b 82 30 03 00 00    	mov    0x330(%rdx),%eax
    26fb:	85 c0                	test   %eax,%eax
    26fd:	7e 17                	jle    2716 <mxml_write_node+0x4c0>
    26ff:	39 c1                	cmp    %eax,%ecx
    2701:	7e 13                	jle    2716 <mxml_write_node+0x4c0>
	  {
	    if ((*putc_cb)('\n', p) < 0)
    2703:	bf 0a 00 00 00       	mov    $0xa,%edi
    2708:	31 db                	xor    %ebx,%ebx
    270a:	41 ff d0             	callq  *%r8
    270d:	85 c0                	test   %eax,%eax
    270f:	79 1a                	jns    272b <mxml_write_node+0x4d5>
    2711:	e9 9f 00 00 00       	jmpq   27b5 <mxml_write_node+0x55f>
	      return (-1);

	    col = 0;
	  }
	  else if ((*putc_cb)(' ', p) < 0)
    2716:	4c 89 ee             	mov    %r13,%rsi
    2719:	bf 20 00 00 00       	mov    $0x20,%edi
    271e:	41 ff d4             	callq  *%r12
    2721:	85 c0                	test   %eax,%eax
    2723:	0f 88 8c 00 00 00    	js     27b5 <mxml_write_node+0x55f>
	    return (-1);
	  else
	    col ++;
    2729:	ff c3                	inc    %ebx
	}

	if (mxml_write_string(node->value.text.string, p, putc_cb) < 0)
    272b:	49 8b 7e 38          	mov    0x38(%r14),%rdi
    272f:	4c 89 e2             	mov    %r12,%rdx
    2732:	4c 89 ee             	mov    %r13,%rsi
    2735:	e8 9f fa ff ff       	callq  21d9 <mxml_write_string>
    273a:	85 c0                	test   %eax,%eax
    273c:	78 77                	js     27b5 <mxml_write_node+0x55f>
	  return (-1);

	col += strlen(node->value.text.string);
    273e:	49 8b 7e 38          	mov    0x38(%r14),%rdi
    2742:	e9 07 ff ff ff       	jmpq   264e <mxml_write_node+0x3f8>
	break;

    case MXML_CUSTOM :
	if (global->custom_save_cb)
    2747:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    274c:	48 8b 82 40 03 00 00 	mov    0x340(%rdx),%rax
    2753:	48 85 c0             	test   %rax,%rax
    2756:	74 5d                	je     27b5 <mxml_write_node+0x55f>
	{
	  char	*data;		/* Custom data string */
	  const char	*newline;	/* Last newline in string */


	  if ((data = (*global->custom_save_cb)(node)) == NULL)
    2758:	ff d0                	callq  *%rax
    275a:	48 85 c0             	test   %rax,%rax
    275d:	48 89 c5             	mov    %rax,%rbp
    2760:	74 53                	je     27b5 <mxml_write_node+0x55f>
	    return (-1);

	  if (mxml_write_string(data, p, putc_cb) < 0)
    2762:	4c 89 e2             	mov    %r12,%rdx
    2765:	4c 89 ee             	mov    %r13,%rsi
    2768:	48 89 c7             	mov    %rax,%rdi
    276b:	e8 69 fa ff ff       	callq  21d9 <mxml_write_string>
    2770:	85 c0                	test   %eax,%eax
    2772:	78 41                	js     27b5 <mxml_write_node+0x55f>
	    return (-1);

	  if ((newline = strrchr(data, '\n')) == NULL)
    2774:	48 89 ef             	mov    %rbp,%rdi
    2777:	be 0a 00 00 00       	mov    $0xa,%esi
    277c:	e8 00 00 00 00       	callq  2781 <mxml_write_node+0x52b>
    2781:	48 85 c0             	test   %rax,%rax
    2784:	48 89 c7             	mov    %rax,%rdi
    2787:	75 14                	jne    279d <mxml_write_node+0x547>
	    col += strlen(data);
    2789:	31 c0                	xor    %eax,%eax
    278b:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    278f:	48 89 ef             	mov    %rbp,%rdi
    2792:	f2 ae                	repnz scas %es:(%rdi),%al
    2794:	48 f7 d1             	not    %rcx
    2797:	8d 5c 0b ff          	lea    -0x1(%rbx,%rcx,1),%ebx
    279b:	eb 0e                	jmp    27ab <mxml_write_node+0x555>
	  else
	    col = strlen(newline);
    279d:	31 c0                	xor    %eax,%eax
    279f:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    27a3:	f2 ae                	repnz scas %es:(%rdi),%al
    27a5:	48 f7 d1             	not    %rcx
    27a8:	8d 59 ff             	lea    -0x1(%rcx),%ebx

	  free(data);
    27ab:	48 89 ef             	mov    %rbp,%rdi
    27ae:	e8 00 00 00 00       	callq  27b3 <mxml_write_node+0x55d>
    27b3:	eb 03                	jmp    27b8 <mxml_write_node+0x562>
	  break;
    27b5:	83 cb ff             	or     $0xffffffffffffffff,%ebx
    default : /* Should never happen */
	return (-1);
  }

  return (col);
}
    27b8:	48 81 c4 58 01 00 00 	add    $0x158,%rsp
    27bf:	89 d8                	mov    %ebx,%eax
    27c1:	5b                   	pop    %rbx
    27c2:	5d                   	pop    %rbp
    27c3:	41 5c                	pop    %r12
    27c5:	41 5d                	pop    %r13
    27c7:	41 5e                	pop    %r14
    27c9:	41 5f                	pop    %r15
    27cb:	c3                   	retq   

00000000000027cc <mxmlSaveString>:
int					/* O - Size of string */
mxmlSaveString(mxml_node_t    *node,	/* I - Node to write */
               char           *buffer,	/* I - String buffer */
               int            bufsize,	/* I - Size of string buffer */
               mxml_save_cb_t cb)	/* I - Whitespace callback or MXML_NO_CALLBACK */
{
    27cc:	41 55                	push   %r13
    27ce:	49 89 fd             	mov    %rdi,%r13
    27d1:	41 54                	push   %r12
    27d3:	49 89 cc             	mov    %rcx,%r12
    27d6:	55                   	push   %rbp
    27d7:	48 89 f5             	mov    %rsi,%rbp
    27da:	53                   	push   %rbx
    27db:	89 d3                	mov    %edx,%ebx
 /*
  * Write the node...
  */

  ptr[0] = buffer;
  ptr[1] = buffer + bufsize;
    27dd:	48 63 db             	movslq %ebx,%rbx
int					/* O - Size of string */
mxmlSaveString(mxml_node_t    *node,	/* I - Node to write */
               char           *buffer,	/* I - String buffer */
               int            bufsize,	/* I - Size of string buffer */
               mxml_save_cb_t cb)	/* I - Whitespace callback or MXML_NO_CALLBACK */
{
    27e0:	48 83 ec 18          	sub    $0x18,%rsp
  int	col;				/* Final column */
  char	*ptr[2];			/* Pointers for putc_cb */
  _mxml_global_t *global = _mxml_global();
    27e4:	e8 00 00 00 00       	callq  27e9 <mxmlSaveString+0x1d>
 /*
  * Write the node...
  */

  ptr[0] = buffer;
  ptr[1] = buffer + bufsize;
    27e9:	48 8d 54 1d 00       	lea    0x0(%rbp,%rbx,1),%rdx

  if ((col = mxml_write_node(node, ptr, cb, 0, mxml_string_putc, global)) < 0)
    27ee:	4c 8d 05 0b d8 ff ff 	lea    -0x27f5(%rip),%r8        # 0 <mxml_string_putc>
    27f5:	31 c9                	xor    %ecx,%ecx
    27f7:	48 89 e6             	mov    %rsp,%rsi
    27fa:	49 89 c1             	mov    %rax,%r9
    27fd:	4c 89 ef             	mov    %r13,%rdi
 /*
  * Write the node...
  */

  ptr[0] = buffer;
  ptr[1] = buffer + bufsize;
    2800:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)

  if ((col = mxml_write_node(node, ptr, cb, 0, mxml_string_putc, global)) < 0)
    2805:	4c 89 e2             	mov    %r12,%rdx

 /*
  * Write the node...
  */

  ptr[0] = buffer;
    2808:	48 89 2c 24          	mov    %rbp,(%rsp)
  ptr[1] = buffer + bufsize;

  if ((col = mxml_write_node(node, ptr, cb, 0, mxml_string_putc, global)) < 0)
    280c:	e8 45 fa ff ff       	callq  2256 <mxml_write_node>
    2811:	83 ca ff             	or     $0xffffffffffffffff,%edx
    2814:	83 f8 00             	cmp    $0x0,%eax
    2817:	7c 31                	jl     284a <mxmlSaveString+0x7e>
    return (-1);

  if (col > 0)
    2819:	74 12                	je     282d <mxmlSaveString+0x61>
  char	**pp;				/* Pointer to string pointers */


  pp = (char **)p;

  if (pp[0] < pp[1])
    281b:	48 8b 04 24          	mov    (%rsp),%rax
    281f:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
    2824:	73 03                	jae    2829 <mxmlSaveString+0x5d>
    pp[0][0] = ch;
    2826:	c6 00 0a             	movb   $0xa,(%rax)

  pp[0] ++;
    2829:	48 ff 04 24          	incq   (%rsp)

 /*
  * Nul-terminate the buffer...
  */

  if (ptr[0] >= ptr[1])
    282d:	48 8b 04 24          	mov    (%rsp),%rax
    2831:	48 3b 44 24 08       	cmp    0x8(%rsp),%rax
    2836:	72 07                	jb     283f <mxmlSaveString+0x73>
    buffer[bufsize - 1] = '\0';
    2838:	c6 44 1d ff 00       	movb   $0x0,-0x1(%rbp,%rbx,1)
    283d:	eb 03                	jmp    2842 <mxmlSaveString+0x76>
  else
    ptr[0][0] = '\0';
    283f:	c6 00 00             	movb   $0x0,(%rax)

 /*
  * Return the number of characters...
  */

  return (ptr[0] - buffer);
    2842:	48 8b 04 24          	mov    (%rsp),%rax
    2846:	89 c2                	mov    %eax,%edx
    2848:	29 ea                	sub    %ebp,%edx
}
    284a:	48 83 c4 18          	add    $0x18,%rsp
    284e:	89 d0                	mov    %edx,%eax
    2850:	5b                   	pop    %rbx
    2851:	5d                   	pop    %rbp
    2852:	41 5c                	pop    %r12
    2854:	41 5d                	pop    %r13
    2856:	c3                   	retq   

0000000000002857 <mxmlSaveFile>:

int					/* O - 0 on success, -1 on error. */
mxmlSaveFile(mxml_node_t    *node,	/* I - Node to write */
             FILE           *fp,	/* I - File to write to */
	     mxml_save_cb_t cb)		/* I - Whitespace callback or MXML_NO_CALLBACK */
{
    2857:	41 54                	push   %r12
    2859:	49 89 fc             	mov    %rdi,%r12
    285c:	55                   	push   %rbp
    285d:	48 89 f5             	mov    %rsi,%rbp
    2860:	53                   	push   %rbx
    2861:	48 89 d3             	mov    %rdx,%rbx
  int	col;				/* Final column */
  _mxml_global_t *global = _mxml_global();
    2864:	e8 00 00 00 00       	callq  2869 <mxmlSaveFile+0x12>

 /*
  * Write the node...
  */

  if ((col = mxml_write_node(node, fp, cb, 0, mxml_file_putc, global)) < 0)
    2869:	4c 8d 05 37 00 00 00 	lea    0x37(%rip),%r8        # 28a7 <mxml_file_putc>
    2870:	31 c9                	xor    %ecx,%ecx
    2872:	49 89 c1             	mov    %rax,%r9
    2875:	48 89 da             	mov    %rbx,%rdx
    2878:	48 89 ee             	mov    %rbp,%rsi
    287b:	4c 89 e7             	mov    %r12,%rdi
    287e:	e8 d3 f9 ff ff       	callq  2256 <mxml_write_node>
    2883:	83 f8 00             	cmp    $0x0,%eax
    2886:	7c 13                	jl     289b <mxmlSaveFile+0x44>
    return (-1);

  if (col > 0)
    2888:	74 16                	je     28a0 <mxmlSaveFile+0x49>
    if (putc('\n', fp) < 0)
    288a:	48 89 ee             	mov    %rbp,%rsi
    288d:	bf 0a 00 00 00       	mov    $0xa,%edi
    2892:	e8 00 00 00 00       	callq  2897 <mxmlSaveFile+0x40>
    2897:	85 c0                	test   %eax,%eax
    2899:	79 05                	jns    28a0 <mxmlSaveFile+0x49>
    289b:	83 c8 ff             	or     $0xffffffffffffffff,%eax
    289e:	eb 02                	jmp    28a2 <mxmlSaveFile+0x4b>
    28a0:	31 c0                	xor    %eax,%eax
 /*
  * Return 0 (success)...
  */

  return (0);
}
    28a2:	5b                   	pop    %rbx
    28a3:	5d                   	pop    %rbp
    28a4:	41 5c                	pop    %r12
    28a6:	c3                   	retq   

00000000000028a7 <mxml_file_putc>:
 */

static int				/* O - 0 on success, -1 on failure */
mxml_file_putc(int  ch,			/* I - Character to write */
               void *p)			/* I - Pointer to file */
{
    28a7:	48 83 ec 08          	sub    $0x8,%rsp
  return (putc(ch, (FILE *)p) == EOF ? -1 : 0);
    28ab:	e8 00 00 00 00       	callq  28b0 <mxml_file_putc+0x9>
    28b0:	89 c2                	mov    %eax,%edx
    28b2:	31 c0                	xor    %eax,%eax
    28b4:	83 fa ff             	cmp    $0xffffffffffffffff,%edx
    28b7:	0f 44 c2             	cmove  %edx,%eax
}
    28ba:	5a                   	pop    %rdx
    28bb:	c3                   	retq   

00000000000028bc <mxml_fd_putc>:
 */

static int				/* O - 0 on success, -1 on error */
mxml_fd_putc(int  ch,			/* I - Character */
             void *p)			/* I - File descriptor buffer */
{
    28bc:	41 55                	push   %r13
    28be:	41 89 fd             	mov    %edi,%r13d
    28c1:	41 54                	push   %r12
    28c3:	55                   	push   %rbp
    28c4:	53                   	push   %rbx
    28c5:	48 89 f3             	mov    %rsi,%rbx
    28c8:	48 83 ec 08          	sub    $0x8,%rsp
  * Flush the write buffer as needed...
  */

  buf = (_mxml_fdbuf_t *)p;

  if (buf->current >= buf->end)
    28cc:	48 8b 46 08          	mov    0x8(%rsi),%rax
    28d0:	48 3b 46 10          	cmp    0x10(%rsi),%rax
    28d4:	72 36                	jb     290c <mxml_fd_putc+0x50>

 /*
  * Return 0 if there is nothing to write...
  */

  if (buf->current == buf->buffer)
    28d6:	4c 8d 66 18          	lea    0x18(%rsi),%r12
    28da:	4c 39 e0             	cmp    %r12,%rax
    28dd:	4c 89 e5             	mov    %r12,%rbp
    28e0:	75 1d                	jne    28ff <mxml_fd_putc+0x43>
    28e2:	eb 28                	jmp    290c <mxml_fd_putc+0x50>
 /*
  * Loop until we have written everything...
  */

  for (ptr = buf->buffer; ptr < buf->current; ptr += bytes)
    if ((bytes = write(buf->fd, ptr, buf->current - ptr)) < 0)
    28e4:	8b 3b                	mov    (%rbx),%edi
    28e6:	48 29 ea             	sub    %rbp,%rdx
    28e9:	48 89 ee             	mov    %rbp,%rsi
    28ec:	e8 00 00 00 00       	callq  28f1 <mxml_fd_putc+0x35>
    28f1:	85 c0                	test   %eax,%eax
    28f3:	79 05                	jns    28fa <mxml_fd_putc+0x3e>
    28f5:	83 c8 ff             	or     $0xffffffffffffffff,%eax
    28f8:	eb 22                	jmp    291c <mxml_fd_putc+0x60>

 /*
  * Loop until we have written everything...
  */

  for (ptr = buf->buffer; ptr < buf->current; ptr += bytes)
    28fa:	48 98                	cltq   
    28fc:	48 01 c5             	add    %rax,%rbp
    28ff:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    2903:	48 39 d5             	cmp    %rdx,%rbp
    2906:	72 dc                	jb     28e4 <mxml_fd_putc+0x28>

 /*
  * All done, reset pointers and return success...
  */

  buf->current = buf->buffer;
    2908:	4c 89 63 08          	mov    %r12,0x8(%rbx)

  if (buf->current >= buf->end)
    if (mxml_fd_write(buf) < 0)
      return (-1);

  *(buf->current)++ = ch;
    290c:	48 8b 43 08          	mov    0x8(%rbx),%rax
    2910:	44 88 28             	mov    %r13b,(%rax)
    2913:	48 ff c0             	inc    %rax
    2916:	48 89 43 08          	mov    %rax,0x8(%rbx)
    291a:	31 c0                	xor    %eax,%eax
 /*
  * Return successfully...
  */

  return (0);
}
    291c:	59                   	pop    %rcx
    291d:	5b                   	pop    %rbx
    291e:	5d                   	pop    %rbp
    291f:	41 5c                	pop    %r12
    2921:	41 5d                	pop    %r13
    2923:	c3                   	retq   

0000000000002924 <mxmlSaveFd>:

int					/* O - 0 on success, -1 on error. */
mxmlSaveFd(mxml_node_t    *node,	/* I - Node to write */
           int            fd,		/* I - File descriptor to write to */
	   mxml_save_cb_t cb)		/* I - Whitespace callback or MXML_NO_CALLBACK */
{
    2924:	41 55                	push   %r13
    2926:	49 89 fd             	mov    %rdi,%r13
    2929:	41 54                	push   %r12
    292b:	49 89 d4             	mov    %rdx,%r12
    292e:	53                   	push   %rbx
    292f:	89 f3                	mov    %esi,%ebx
    2931:	48 81 ec 20 20 00 00 	sub    $0x2020,%rsp
  int		col;			/* Final column */
  _mxml_fdbuf_t	buf;			/* File descriptor buffer */
  _mxml_global_t *global = _mxml_global();
    2938:	e8 00 00 00 00       	callq  293d <mxmlSaveFd+0x19>
 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
  buf.current = buf.buffer;
    293d:	48 8d 54 24 18       	lea    0x18(%rsp),%rdx

 /*
  * Write the node...
  */

  if ((col = mxml_write_node(node, &buf, cb, 0, mxml_fd_putc, global)) < 0)
    2942:	4c 8d 05 73 ff ff ff 	lea    -0x8d(%rip),%r8        # 28bc <mxml_fd_putc>
    2949:	31 c9                	xor    %ecx,%ecx
    294b:	49 89 c1             	mov    %rax,%r9
    294e:	48 89 e6             	mov    %rsp,%rsi
    2951:	4c 89 ef             	mov    %r13,%rdi
 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
  buf.current = buf.buffer;
    2954:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  buf.end     = buf.buffer + sizeof(buf.buffer);
    2959:	48 8d 94 24 18 20 00 	lea    0x2018(%rsp),%rdx
    2960:	00 

 /*
  * Initialize the file descriptor buffer...
  */

  buf.fd      = fd;
    2961:	89 1c 24             	mov    %ebx,(%rsp)
  buf.current = buf.buffer;
  buf.end     = buf.buffer + sizeof(buf.buffer);
    2964:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)

 /*
  * Write the node...
  */

  if ((col = mxml_write_node(node, &buf, cb, 0, mxml_fd_putc, global)) < 0)
    2969:	4c 89 e2             	mov    %r12,%rdx
    296c:	e8 e5 f8 ff ff       	callq  2256 <mxml_write_node>
    2971:	83 f8 00             	cmp    $0x0,%eax
    2974:	7c 47                	jl     29bd <mxmlSaveFd+0x99>
    return (-1);

  if (col > 0)
    2976:	74 11                	je     2989 <mxmlSaveFd+0x65>
    if (mxml_fd_putc('\n', &buf) < 0)
    2978:	48 89 e6             	mov    %rsp,%rsi
    297b:	bf 0a 00 00 00       	mov    $0xa,%edi
    2980:	e8 37 ff ff ff       	callq  28bc <mxml_fd_putc>
    2985:	85 c0                	test   %eax,%eax
    2987:	78 34                	js     29bd <mxmlSaveFd+0x99>

 /*
  * Return 0 if there is nothing to write...
  */

  if (buf->current == buf->buffer)
    2989:	48 8d 44 24 18       	lea    0x18(%rsp),%rax
    298e:	48 39 44 24 08       	cmp    %rax,0x8(%rsp)
    2993:	48 89 c3             	mov    %rax,%rbx
    2996:	75 19                	jne    29b1 <mxmlSaveFd+0x8d>
    2998:	eb 28                	jmp    29c2 <mxmlSaveFd+0x9e>
 /*
  * Loop until we have written everything...
  */

  for (ptr = buf->buffer; ptr < buf->current; ptr += bytes)
    if ((bytes = write(buf->fd, ptr, buf->current - ptr)) < 0)
    299a:	8b 3c 24             	mov    (%rsp),%edi
    299d:	48 29 da             	sub    %rbx,%rdx
    29a0:	48 89 de             	mov    %rbx,%rsi
    29a3:	e8 00 00 00 00       	callq  29a8 <mxmlSaveFd+0x84>
    29a8:	85 c0                	test   %eax,%eax
    29aa:	78 11                	js     29bd <mxmlSaveFd+0x99>

 /*
  * Loop until we have written everything...
  */

  for (ptr = buf->buffer; ptr < buf->current; ptr += bytes)
    29ac:	48 98                	cltq   
    29ae:	48 01 c3             	add    %rax,%rbx
    29b1:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    29b6:	48 39 d3             	cmp    %rdx,%rbx
    29b9:	72 df                	jb     299a <mxmlSaveFd+0x76>
    29bb:	eb 05                	jmp    29c2 <mxmlSaveFd+0x9e>
    29bd:	83 c8 ff             	or     $0xffffffffffffffff,%eax
    29c0:	eb 02                	jmp    29c4 <mxmlSaveFd+0xa0>
    29c2:	31 c0                	xor    %eax,%eax
 /*
  * Flush and return...
  */

  return (mxml_fd_write(&buf));
}
    29c4:	48 81 c4 20 20 00 00 	add    $0x2020,%rsp
    29cb:	5b                   	pop    %rbx
    29cc:	41 5c                	pop    %r12
    29ce:	41 5d                	pop    %r13
    29d0:	c3                   	retq   

00000000000029d1 <mxmlSaveAllocString>:

char *					/* O - Allocated string or NULL */
mxmlSaveAllocString(
    mxml_node_t    *node,		/* I - Node to write */
    mxml_save_cb_t cb)			/* I - Whitespace callback or MXML_NO_CALLBACK */
{
    29d1:	41 55                	push   %r13

 /*
  * Write the node to the temporary buffer...
  */

  bytes = mxmlSaveString(node, buffer, sizeof(buffer), cb);
    29d3:	48 89 f1             	mov    %rsi,%rcx
    29d6:	ba 00 20 00 00       	mov    $0x2000,%edx

char *					/* O - Allocated string or NULL */
mxmlSaveAllocString(
    mxml_node_t    *node,		/* I - Node to write */
    mxml_save_cb_t cb)			/* I - Whitespace callback or MXML_NO_CALLBACK */
{
    29db:	49 89 fd             	mov    %rdi,%r13
    29de:	41 54                	push   %r12
    29e0:	49 89 f4             	mov    %rsi,%r12
    29e3:	55                   	push   %rbp
    29e4:	53                   	push   %rbx
  * Write the node to the temporary buffer...
  */

  bytes = mxmlSaveString(node, buffer, sizeof(buffer), cb);

  if (bytes <= 0)
    29e5:	31 db                	xor    %ebx,%ebx

char *					/* O - Allocated string or NULL */
mxmlSaveAllocString(
    mxml_node_t    *node,		/* I - Node to write */
    mxml_save_cb_t cb)			/* I - Whitespace callback or MXML_NO_CALLBACK */
{
    29e7:	48 81 ec 08 20 00 00 	sub    $0x2008,%rsp

 /*
  * Write the node to the temporary buffer...
  */

  bytes = mxmlSaveString(node, buffer, sizeof(buffer), cb);
    29ee:	48 89 e6             	mov    %rsp,%rsi
    29f1:	e8 00 00 00 00       	callq  29f6 <mxmlSaveAllocString+0x25>

  if (bytes <= 0)
    29f6:	85 c0                	test   %eax,%eax
    29f8:	7e 37                	jle    2a31 <mxmlSaveAllocString+0x60>
    return (NULL);

  if (bytes < (int)(sizeof(buffer) - 1))
    29fa:	3d fe 1f 00 00       	cmp    $0x1ffe,%eax
    29ff:	7f 0d                	jg     2a0e <mxmlSaveAllocString+0x3d>
   /*
    * Node fit inside the buffer, so just duplicate that string and
    * return...
    */

    return (strdup(buffer));
    2a01:	48 89 e7             	mov    %rsp,%rdi
    2a04:	e8 00 00 00 00       	callq  2a09 <mxmlSaveAllocString+0x38>
    2a09:	48 89 c3             	mov    %rax,%rbx
    2a0c:	eb 23                	jmp    2a31 <mxmlSaveAllocString+0x60>
 /*
  * Allocate a buffer of the required size and save the node to the
  * new buffer...
  */

  if ((s = malloc(bytes + 1)) == NULL)
    2a0e:	8d 68 01             	lea    0x1(%rax),%ebp
    2a11:	48 63 fd             	movslq %ebp,%rdi
    2a14:	e8 00 00 00 00       	callq  2a19 <mxmlSaveAllocString+0x48>
    2a19:	48 85 c0             	test   %rax,%rax
    2a1c:	48 89 c3             	mov    %rax,%rbx
    2a1f:	74 10                	je     2a31 <mxmlSaveAllocString+0x60>
    return (NULL);

  mxmlSaveString(node, s, bytes + 1, cb);
    2a21:	4c 89 e1             	mov    %r12,%rcx
    2a24:	89 ea                	mov    %ebp,%edx
    2a26:	48 89 c6             	mov    %rax,%rsi
    2a29:	4c 89 ef             	mov    %r13,%rdi
    2a2c:	e8 00 00 00 00       	callq  2a31 <mxmlSaveAllocString+0x60>
 /*
  * Return the allocated string...
  */

  return (s);
}
    2a31:	48 81 c4 08 20 00 00 	add    $0x2008,%rsp
    2a38:	48 89 d8             	mov    %rbx,%rax
    2a3b:	5b                   	pop    %rbx
    2a3c:	5d                   	pop    %rbp
    2a3d:	41 5c                	pop    %r12
    2a3f:	41 5d                	pop    %r13
    2a41:	c3                   	retq   
